
; ~ [SURFACE]

Include "SourceCode\Rooms\Surface\Gate_A_Intro.bb"
Include "SourceCode\Rooms\Surface\Gate_A_Road.bb"
Include "SourceCode\Rooms\Surface\Gate_A_Topside.bb"
Include "SourceCode\Rooms\Surface\Gate_B_Topside.bb"
Include "SourceCode\Rooms\Surface\Gate_C_Topside.bb"
Include "SourceCode\Rooms\Surface\Gate_D_Topside.bb"

; ~ [ENTRANCE ZONE]

Include "SourceCode\Rooms\EZ\Area_2935.bb"
Include "SourceCode\Rooms\EZ\Evac_Shelter.bb"
Include "SourceCode\Rooms\EZ\Gate_A_Entrance.bb"
Include "SourceCode\Rooms\EZ\Gate_B_Entrance.bb"
Include "SourceCode\Rooms\EZ\Gate_C_Entrance.bb"
Include "SourceCode\Rooms\EZ\Gate_D_Entrance.bb"
Include "SourceCode\Rooms\EZ\Lockroom_2.bb"
Include "SourceCode\Rooms\EZ\Room2_Toilets.bb"
Include "SourceCode\Rooms\EZ\Personnel_offices.bb"
Include "SourceCode\Rooms\EZ\Room1_Elevators.bb"
Include "SourceCode\Rooms\EZ\Room1_Sky_Office.bb"
Include "SourceCode\Rooms\EZ\Room1_O5.bb"
Include "SourceCode\Rooms\EZ\Room2_EZ_1.bb"
Include "SourceCode\Rooms\EZ\Room2_Medibay.bb"
Include "SourceCode\Rooms\EZ\Room2_Rocky.bb"
Include "SourceCode\Rooms\EZ\Room2_Upper_Office.bb"
Include "SourceCode\Rooms\EZ\Room2_Offices_1.bb"
Include "SourceCode\Rooms\EZ\Room2_Offices_2.bb"
Include "SourceCode\Rooms\EZ\Room2_Offices_3.bb"
Include "SourceCode\Rooms\EZ\Room2_Offices_5.bb"
Include "SourceCode\Rooms\EZ\Room2_WS.bb"
Include "SourceCode\Rooms\EZ\Room2C_EWS.bb"
Include "SourceCode\Rooms\EZ\Room2C_EZ.bb"
Include "SourceCode\Rooms\EZ\Room2C_Office_EZ.bb"
Include "SourceCode\Rooms\EZ\Room2C_Research.bb"
Include "SourceCode\Rooms\EZ\Room3_EZ.bb"
Include "SourceCode\Rooms\EZ\Room3_GW.bb"
Include "SourceCode\Rooms\EZ\Room4_EZ.bb"

; ~ [BIOLOGiCAL CONTAINMENT ZONE]

Include "SourceCode\Rooms\BCZ\Cont_008.bb"
Include "SourceCode\Rooms\BCZ\Cont_016.bb"
Include "SourceCode\Rooms\BCZ\Cont_409.bb"
Include "SourceCode\Rooms\BCZ\Room2_BCZ.bb"
Include "SourceCode\Rooms\BCZ\Room2_2_BCZ.bb"
Include "SourceCode\Rooms\BCZ\Room2_3_BCZ.bb"
Include "SourceCode\Rooms\BCZ\Room2C_BCZ.bb"
Include "SourceCode\Rooms\BCZ\Room2_Offices_BCZ.bb"
Include "SourceCode\Rooms\BCZ\Room3_BCZ.bb"
Include "SourceCode\Rooms\BCZ\Room4_BCZ.bb"

; ~ [LIGHT CONTAINMENT ZONE]

Include "SourceCode\Rooms\LCZ\Room2_2.bb"
Include "SourceCode\Rooms\LCZ\Room2_PF.bb"
Include "SourceCode\Rooms\LCZ\Cont_173.bb"
Include "SourceCode\Rooms\LCZ\Room2_Doors.bb"
Include "SourceCode\Rooms\LCZ\Room2_Closets.bb"
Include "SourceCode\Rooms\LCZ\Room1_Archive.bb"
Include "SourceCode\Rooms\LCZ\Cont_005.bb"
Include "SourceCode\Rooms\LCZ\Cont_1162.bb"
Include "SourceCode\Rooms\LCZ\Cont_372_914.bb"
Include "SourceCode\Rooms\LCZ\Cont_500_1499.bb"
Include "SourceCode\Rooms\LCZ\Cont_109_198_357_402_447.bb"
Include "SourceCode\Rooms\LCZ\Cont_207_268_1079_1033RU.bb"
Include "SourceCode\Rooms\LCZ\Cont_427_714_860_1025.bb"
Include "SourceCode\Rooms\LCZ\Room1_Intro.bb"
Include "SourceCode\Rooms\LCZ\Room1_Start.bb"
Include "SourceCode\Rooms\LCZ\Surveil_Room.bb"
Include "SourceCode\Rooms\LCZ\Endroom_1.bb"
Include "SourceCode\Rooms\LCZ\Testroom_860.bb"
Include "SourceCode\Rooms\LCZ\Testroom_2b.bb"
Include "SourceCode\Rooms\LCZ\Lockroom_1.bb"
Include "SourceCode\Rooms\LCZ\Lockroom_3.bb"
Include "SourceCode\Rooms\LCZ\Room2_Generators_LCZ.bb"
Include "SourceCode\Rooms\LCZ\Room2_GW.bb"
Include "SourceCode\Rooms\LCZ\Room2_LWS.bb"
Include "SourceCode\Rooms\LCZ\Room4_Ventilation.bb"
Include "SourceCode\Rooms\LCZ\Room2_Ventilation.bb"
Include "SourceCode\Rooms\LCZ\Room2_Tesla.bb"
Include "SourceCode\Rooms\LCZ\Room3_Info.bb"

; ~ [HEAVY CONTAINMENT ZONE]

Include "SourceCode\Rooms\HCZ\Checkpoint_ACZ.bb"
Include "SourceCode\Rooms\HCZ\Cont_049.bb"
Include "SourceCode\Rooms\HCZ\Cont_059.bb"
Include "SourceCode\Rooms\HCZ\Cont_079.bb"
Include "SourceCode\Rooms\HCZ\Cont_457.bb"
Include "SourceCode\Rooms\HCZ\Cont_513.bb"
Include "SourceCode\Rooms\HCZ\Cont_966.bb"
Include "SourceCode\Rooms\HCZ\Room1_Sewers.bb"
Include "SourceCode\Rooms\HCZ\Room2_Maintenance.bb"
Include "SourceCode\Rooms\HCZ\Room2_Nuke.bb"
Include "SourceCode\Rooms\HCZ\Room2_Pipes_1.bb"
Include "SourceCode\Rooms\HCZ\Room2_Pipes_2.bb"
Include "SourceCode\Rooms\HCZ\Room2_Pit.bb"
Include "SourceCode\Rooms\HCZ\Room2_Tunnel_2.bb"
Include "SourceCode\Rooms\HCZ\Room2C_HWS.bb"
Include "SourceCode\Rooms\HCZ\Room2C_Pit.bb"
Include "SourceCode\Rooms\HCZ\Room3_CT.bb"
Include "SourceCode\Rooms\HCZ\Room3_HCZ.bb"
Include "SourceCode\Rooms\HCZ\Room3_Pit.bb"
Include "SourceCode\Rooms\HCZ\Room3_Tunnel_1.bb"
Include "SourceCode\Rooms\HCZ\Room3_Tunnel_2.bb"

; ~ [REINFORCED CONTAINMENT ZONE]

Include "SourceCode\Rooms\RCZ\Area_076.bb"
Include "SourceCode\Rooms\RCZ\Cont_106.bb"
Include "SourceCode\Rooms\RCZ\Room1_SWS.bb"
Include "SourceCode\Rooms\RCZ\Room2_Info.bb"

; ~ [OTHER]

Include "SourceCode\Rooms\Other\Core.bb"
Include "SourceCode\Rooms\Other\Checkpoint.bb"
Include "SourceCode\Rooms\Other\ClassD_Cells.bb"
Include "SourceCode\Rooms\Other\Facility_Reactor.bb"
Include "SourceCode\Rooms\Other\PocketDimension.bb"
Include "SourceCode\Rooms\Other\Area_035_NTF_Encounter.bb"
Include "SourceCode\Rooms\Other\Area_106_Escape.bb"

;Map constants
;[Block]
Const MaxRoomLights% = 512 ;128
Const MaxRoomEmitters% = 16
Const MaxRoomObjects% = 30
Const MaxZones% = 15

Const ROOM1% = 1, ROOM2% = 2, ROOM2C% = 3, ROOM3% = 4, ROOM4% = 5

Const MapGridSize% = 18 ;12
Const MapGrid_NoTile% = 0
Const MapGrid_Tile% = 1
Const MapGrid_StartTile% = 2
Const MapGrid_EndTile% = 3

Const GATE_A_INTRO% = 0
Const LCZ% = 1
Const HCZ% = 2
Const EZ% = 3
Const RCZ% = 4
Const BCZ% = 5
Const REACTOR_AREA% = 6
Const CLASSD_CELLS% = 7
Const GATE_A_ROAD% = 8
Const GATE_A_TOPSIDE% = 9
Const GATE_B_TOPSIDE% = 10
Const GATE_C_TOPSIDE% = 11
Const GATE_D_TOPSIDE% = 12
Const AREA_076% = 13
Const AREA_106_ESCAPE% = 14

Const FogColor_LCZ$ = 					"010010010"
Const FogColor_HCZ$ = 					"010006006"
Const FogColor_EZ$ = 					"010010020"
Const FogColor_RCZ$ = 					"006006010"
Const FogColor_BCZ$ = 					"100100100"
Const FogColor_Sewers$ = 				"005020003"
Const FogColor_Forest$ = 				"048127255"
Const FogColor_Forest_2$ = 				"098133162"
Const FogColor_Outside$ = 				"255255255"
Const FogColor_Outside_Night$ = 		"002002020"
Const FogColor_PD$ = 					"000000000"
Const FogColor_PDTrench$ = 				"038055047"
Const FogColor_Area_076$ = 				"001002022"
Const FogColor_Area_106_Escape$ = 		"005005005"
;[End Block]

Function FillRoom(r.Rooms)
	CatchErrors("Uncaught (FillRoom)")
	Local em.Emitters,lt.LightTemplates,ts.TempScreens,tw.TempWayPoints
	Local i%
	Local t1
	
	Local tfll.TempFluLight,fll.FluLight
	For tfll.TempFluLight = Each TempFluLight
		If tfll\roomtemplate = r\RoomTemplate Then
			fll = CreateFluLight(tfll\id)
			PositionEntity fll\obj,r\x+tfll\position\x,r\y+tfll\position\y,r\z+tfll\position\z
			RotateEntity fll\obj,tfll\rotation\x,tfll\rotation\y,tfll\rotation\z
			EntityPickMode fll\obj,2
			EntityParent fll\obj,r\obj
			PositionEntity fll\lightobj,r\x+tfll\position\x,r\y+tfll\position\y,r\z+tfll\position\z
			EntityParent fll\lightobj,fll\obj
			PositionEntity fll\flashsprite,r\x+tfll\position\x,r\y+tfll\position\y-0.07,r\z+tfll\position\z
			EntityParent fll\flashsprite,fll\obj
			fll\room = r
		EndIf
	Next
	
	Select r\RoomTemplate\Name
		Case "core_ez","core_hcz","core_lcz"
			FillRoom_Cores(r)
		Case "checkpoint_bcz","checkpoint_hcz","checkpoint_rcz"
			FillRoom_Checkpoints(r)
		Case "class_d_cells_entrance"
			FillRoom_ClassD_Cells_Checkpoint(r)
		Case "class_d_cells"
			FillRoom_ClassD_Cells_Zone(r)
		Case "gate_a_intro"
			FillRoom_Gate_A_Intro(r)
		Case "gate_a_road"
			FillRoom_Gate_A_Road(r)
		Case "gate_a_topside"
			FillRoom_Gate_A_Topside(r)
		Case "gate_b_topside"
			FillRoom_Gate_B_Topside(r)
		Case "gate_c_topside"
			FillRoom_Gate_C_Topside(r)
		Case "gate_d_topside"
			FillRoom_Gate_D_Topside(r)
		Case "gate_a_entrance"
			FillRoom_Gate_A_Entrance(r)
		Case "gate_b_entrance"
			FillRoom_Gate_B_Entrance(r)
		Case "gate_c_entrance"
			FillRoom_Gate_C_Entrance(r)
		Case "gate_d_entrance"
			FillRoom_Gate_D_Entrance(r)
		Case "personnel_offices"
			FillRoom_Personnel_Offices(r)
		Case "room1_sky_office"
			FillRoom_Room1_Sky_Office(r)
		Case "room1_elevators"
			FillRoom_Room1_Elevators(r)
		Case "room1_o5"
			FillRoom_Room1_O5(r)
		Case "area_076_entrance"
			FillRoom_Area_076_Entrance(r)
		Case "area_076"
			FillRoom_Area_076(r)
		Case "cont_106"
			FillRoom_Cont_106(r)
		Case "room1_sws"
			FillRoom_Room1_Sws(r)
		Case "room2_info"
			FillRoom_Room2_Info(r)
		Case "room2_ez_1"
			FillRoom_Room2_EZ_1(r)
		Case "room2_offices_1"
			FillRoom_Room2_Offices_1(r)
		Case "room2_offices_2"
			FillRoom_Room2_Offices_2(r)
		Case "room2_offices_3"
			FillRoom_Room2_Offices_3(r)
		Case "room2_offices_5"
			FillRoom_Room2_Offices_5(r)
		Case "cont_008"
			FillRoom_Cont_008(r)
		Case "cont_016"
			FillRoom_Cont_016(r)
		Case "cont_409"
			FillRoom_Cont_409(r)
		Case "room2_bcz"
			FillRoom_Room2_BCZ(r)
		Case "room2_2_bcz"
			FillRoom_Room2_2_BCZ(r)
		Case "room2_3_bcz"
			FillRoom_Room2_3_BCZ(r)
		Case "room2c_bcz"
			FillRoom_Room2C_BCZ(r)
		Case "room2_offices_bcz"
			FillRoom_Room2_Offices_BCZ(r)
		Case "room3_bcz"
			FillRoom_Room3_BCZ(r)
		Case "room4_bcz"
			FillRoom_Room4_BCZ(r)
		Case "room2_ws"
			FillRoom_Room2_Ws(r)
		Case "room2c_ews"
			FillRoom_Room2C_Ews(r)
		Case "room2c_ez"
			FillRoom_Room2C_Ez(r)
		Case "room2c_office_ez"
			FillRoom_Room2C_Office_Ez(r)
		Case "room2c_research"
			FillRoom_Room2C_Research(r)
		Case "room3_ez"
			FillRoom_Room3_EZ(r)
		Case "room3_gw"
			FillRoom_Room3_GW(r)
		Case "room4_ez"
			FillRoom_Room4_EZ(r)
		Case "room2_pf"
			FillRoom_Room2_PF(r)
		Case "room1_intro"
			FillRoom_Room1_Intro(r)
		Case "room1_start"
			FillRoom_Room1_Start(r)
		Case "room1_sewers"
			FillRoom_Room1_Sewers(r)
		Case "room2_maintenance"
			FillRoom_Room2_Maintenance(r)
		Case "room2_nuke"
			FillRoom_Room2_Nuke(r)
		Case "room2_medibay"
			FillRoom_Room2_Medibay(r)
		Case "room2_rocky"
			FillRoom_Room2_Rocky(r)
		Case "room2_upper_office"
			FillRoom_Room2_Upper_Office(r)
		Case "room2_pipes_1"
			FillRoom_Room2_Pipes_1(r)
		Case "room2_pipes_2"
			FillRoom_Room2_Pipes_2(r)
		Case "room2_pit"
			FillRoom_Room2_Pit(r)
		Case "room3_pit"
			FillRoom_Room3_Pit(r)
		Case "room2c_pit"
			FillRoom_Room2C_Pit(r)
		Case "room2_tunnel_2"
			FillRoom_Room2_Tunnel_2(r)
		Case "room3_tunnel_1"
			Fillroom_Room3_Tunnel_1(r)
		Case "room3_tunnel_2"
			Fillroom_Room3_Tunnel_2(r)
		Case "room3_hcz"
			FillRoom_Room3_HCZ(r)
		Case "room2c_hws"
			FillRoom_Room2C_Hws(r)
		Case "endroom_1"
			FillRoom_Endroom_1(r)
		Case "evac_shelter"
			FillRoom_Evac_Shelter(r)
		Case "area_2935_entrance"
			FillRoom_Area_2935_Entrance(r)
		Case "area_106_escape"
			FillRoom_Area_106_Escape(r)
		Case "area_035_ntf_encounter"
			FillRoom_Area_035_NTF_Encounter(r)
		Case "cont_005"
			FillRoom_Cont_005(r)
		Case "cont_173"
			FillRoom_Cont_173(r)
		Case "cont_049"
			FillRoom_Cont_049(r)
		Case "cont_059"
			FillRoom_Cont_059(r)
		Case "cont_079"
			FillRoom_Cont_079(r)
		Case "cont_457"
			FillRoom_Cont_457(r)
		Case "cont_513"
			FillRoom_Cont_513(r)
		Case "cont_966"
			FillRoom_Cont_966(r)
		Case "cont_1162"
			FillRoom_Cont_1162(r)
		Case "cont_372_914"
			FillRoom_Cont_372_914(r)
		Case "pocketdimension"
			FillRoom_Pocketdimension(r)
		Case "facility_reactor_entrance"
			FillRoom_Facility_Reactor_Entrance(r)
		Case "facility_reactor"
			FillRoom_Facility_Reactor(r)
		Case "cont_500_1499"
			FillRoom_Cont_500_1499(r)
		Case "cont_109_198_357_402_447"
			FillRoom_Cont_109_198_357_402_447(r)
		Case "cont_427_714_860_1025"
			FillRoom_Cont_427_714_860_1025(r)
		Case "cont_207_268_1079_1033ru"
			FillRoom_Cont_207_268_1079_1033RU(r)
		Case "testroom_860"
			FillRoom_Testroom_860(r)
		Case "lockroom_1"
			FillRoom_Lockroom_1(r)
		Case "lockroom_2"
			FillRoom_Lockroom_2(r)
		Case "lockroom_3"
			FillRoom_Lockroom_3(r)
		Case "room1_archive"
			FillRoom_Room1_Archive(r)
		Case "room2_2"
			FillRoom_Room2_2(r)
		Case "room2_lws"
			FillRoom_Room2_Lws(r)
		Case "room3_ct"
			FillRoom_Room3_CT(r)
		Case "room2_3","room3_3"
			Local w.WayPoints = CreateWaypoint(r\x, r\y + 66.0 * RoomScale, r\z, Null, r) ;I guess that can still be like that - ENDSHN
		Case "room2_closets"
			FillRoom_Room2_Closets(r)
		Case "room2_doors"
			FillRoom_Room2_Doors(r)
		Case "room2_gw_a","room2_gw_b"
			FillRoom_Room2_GW(r)
		Case "room4_tunnel"
			FillRoom_Room4_Tunnel(r)	
		Case "surveil_room"
			FillRoom_Surveil_Room(r)
		Case "room2_tesla_lcz","room2_tesla_hcz"
			FillRoom_Room2_Tesla(r)
		Case "room2_toilets"
			Fillroom_Room2_Toilets(r)
		Case "room2_ventilation"
			FillRoom_Room2_Ventilation(r)
		Case "room4_ventilation"
			FillRoom_Room4_Ventilation(r)
		Case "room3_info"
			FillRoom_Room3_Info(r)
		Case "checkpoint_acz"
			FillRoom_Checkpoint_ACZ(r)
		Case "testroom_2b"
			FillRoom_Testroom_2B(r)
	End Select
	
	For lt.LightTemplates = Each LightTemplates
		If lt\roomtemplate = r\RoomTemplate Then
			newlt = AddLight(r, r\x+lt\x, r\y+lt\y, r\z+lt\z, lt\ltype, lt\range, lt\r, lt\g, lt\b)
			If newlt <> 0 Then
				If lt\ltype = 3 Then
					LightConeAngles(newlt, lt\innerconeangle, lt\outerconeangle)
					RotateEntity(newlt, lt\pitch, lt\yaw, 0)
				EndIf
			EndIf
		EndIf
	Next
	
	For ts.TempScreens = Each TempScreens
		If ts\roomtemplate = r\RoomTemplate Then
			CreateScreen(r\x+ts\x, r\y+ts\y, r\z+ts\z, ts\imgpath, r)
		EndIf
	Next
	
	For tw.TempWayPoints = Each TempWayPoints
		If tw\roomtemplate = r\RoomTemplate Then
			CreateWaypoint(r\x+tw\x, r\y+tw\y, r\z+tw\z, Null, r)
		EndIf
	Next
	
	If r\RoomTemplate\TempTriggerboxAmount > 0
		r\TriggerboxAmount = r\RoomTemplate\TempTriggerboxAmount
		For i = 0 To r\TriggerboxAmount-1
			r\Triggerboxes[i] = New Triggerbox
			r\Triggerboxes[i]\obj = CopyEntity(r\RoomTemplate\TempTriggerbox[i],r\obj)
			EntityColor(r\Triggerboxes[i]\obj,255,255,0)
			EntityAlpha(r\Triggerboxes[i]\obj, 0.0)
			r\Triggerboxes[i]\Name = r\RoomTemplate\TempTriggerboxName[i]
			;debuglog "Triggerbox found: "+i
			;debuglog "Triggerbox "+i+" name: "+r\Triggerboxes[i]\Name
		Next
	EndIf
	
	For i = 0 To MaxRoomEmitters-1
		If r\RoomTemplate\TempSoundEmitter[i]<>0 Then
			r\SoundEmitterObj[i]=CreatePivot(r\obj)
			PositionEntity r\SoundEmitterObj[i], r\x+r\RoomTemplate\TempSoundEmitterX[i],r\y+r\RoomTemplate\TempSoundEmitterY[i],r\z+r\RoomTemplate\TempSoundEmitterZ[i],True
			EntityParent(r\SoundEmitterObj[i],r\obj)
			
			r\SoundEmitter[i] = r\RoomTemplate\TempSoundEmitter[i]
			r\SoundEmitterRange[i] = r\RoomTemplate\TempSoundEmitterRange[i]
		EndIf
	Next
	
	;Mark all room created particle emitter as map generated
	For em = Each Emitters
		em\map_generated = True
	Next
	
	CatchErrors("FillRoom ("+r\RoomTemplate\Name+")")
End Function

Function InteractWithObject%(obj%, dist#, arrow% = False, arrowID% = 0, KeyDown_% = False)
	If InvOpen Lor OtherOpen <> Null Lor d_I\SelectedDoor <> Null Lor SelectedScreen <> Null Then Return
	
	If EntityDistanceSquared(Collider, obj) < PowTwo(dist) Then
		If EntityInView(obj, Camera) Then
			If arrow Then DrawArrowIcon[arrowID] = True
			DrawHandIcon = True
			If KeyDown_ Then
				If KeyDownUse Then Return(True)
			Else
				If KeyHitUse Then Return(True)
			EndIf
		EndIf
	EndIf
	
	Return(False)
End Function

;RMESH STUFF;;;;

Function StripFilename$(file$)
	Local mi$=""
	Local lastSlash%=0
	If Len(file)>0
		For i%=1 To Len(file)
			mi=Mid(file$,i,1)
			If mi="\" Lor mi="/" Then
				lastSlash=i
			EndIf
		Next
	EndIf
	
	Return Left(file,lastSlash)
End Function

Const RMESH_BSP = 2
Const RMESH_INVISBLE = 3

Function LoadRMesh(file$,rt.RoomTemplates, doublesided=True)
	CatchErrors("Uncaught (LoadRMesh)")
	
	;debuglog "Loading RMesh file "+file
	
	Local mat.Materials
	
	ClsColor 0,0,0
	
	;read the file
	Local f%=ReadFile(file)
	Local i%,j%,k%,x#,y#,z#,yaw#
	Local vertex%
	Local temp1i%,temp2i%,temp3i%
	Local temp1#,temp2#,temp3#
	Local temp1s$, temp2s$
	
	Local collisionMeshes% = CreatePivot()
	
	Local hasTriggerBox% = False
	
	Local hasNoColl% = False
	
	For i=0 To 3 ;reattempt up to 3 times
		If f=0 Then
			f=ReadFile(file)
		Else
			Exit
		EndIf
	Next
	If f=0 Then RuntimeError "Error reading file "+Chr(34)+file+Chr(34)
	Local isRMesh$ = ReadString(f)
	If Instr(isRMesh,"RoomMesh") = 0 Then
		RuntimeError Chr(34)+file+Chr(34)+" is Not RMESH ("+isRMesh+")"
	EndIf
	If Instr(isRMesh,".HasTriggerBox") > 0 Then
		hasTriggerBox% = True
	EndIf
	If Instr(isRMesh,".HasNoColl") > 0 Then
		hasNoColl% = True
	EndIf
	
	file=StripFilename(file)
	
	Local count%,count2%
	
	;drawn meshes
	Local Opaque%,Alpha%
	
	Opaque=CreateMesh()
	Alpha=CreateMesh()
	
	count = ReadInt(f)
	Local childMesh%
	Local surf%,tex%[2],brush%
	
	Local isAlpha%
	
	Local u#,v#
	
	;[Block]
	For i=1 To count ;drawn mesh
		childMesh=CreateMesh()
		
		surf=CreateSurface(childMesh)
		
		brush=CreateBrush()
		
		tex[0]=0 : tex[1]=0
		
		Local reflectiontex = 0
		
		isAlpha=0
		
		For j=0 To 1
			temp1i=ReadByte(f)
			If temp1i<>0 Then
				temp1s=ReadString(f)
				If FileType(file+temp1s)=1 Then ;Check if texture is existing in original path
					If temp1i<3
						If Instr(Lower(temp1s),"_lm")<>0 Then
							tex[j]=LoadTextureCheckingIfInCache(file+temp1s,0,1+256)
						Else
							tex[j]=LoadTextureCheckingIfInCache(file+temp1s,0,1)
						EndIf	
					Else
						tex[j]=LoadTextureCheckingIfInCache(file+temp1s,0,3)
					EndIf
				ElseIf FileType(MapTexturesFolder+temp1s)=1 Then ;If not, check the MapTexturesFolder
					If temp1i<3
						If Instr(Lower(temp1s),"_lm")<>0 Then
							tex[j]=LoadTextureCheckingIfInCache(MapTexturesFolder+temp1s,0,1+256)
						Else
							tex[j]=LoadTextureCheckingIfInCache(MapTexturesFolder+temp1s,0,1)
						EndIf	
					Else
						tex[j]=LoadTextureCheckingIfInCache(MapTexturesFolder+temp1s,0,3)
					EndIf
				EndIf
				If tex[j]<>0 Then
					If temp1i=1 Then TextureBlend tex[j],5
					If Instr(Lower(temp1s),"_lm")<>0 Then
						TextureBlend tex[j],3
					EndIf
					
					isAlpha=2
					If temp1i=3 Then isAlpha=1
					TextureCoords tex[j],1-j
				EndIf
			EndIf
		Next
		
		If isAlpha=1 Then
			If tex[1]<>0 Then
				TextureBlend tex[1],2
				BrushTexture brush,tex[1],0,0
			Else
				BrushTexture brush,MissingTexture,0,0
			EndIf
		Else
			Local bumptex = 0
			If tex[0]<>0 And tex[1]<>0
				If BumpEnabled
					Local temp$ = StripPath(TextureName(tex[1]))
					For mat = Each Materials
						If mat\name = temp$ Then
							bumptex = mat\Bump
							Exit
						EndIf
					Next
				Else
					bumptex=0
				EndIf
				If bumptex=0
					For j=0 To 1
						BrushTexture brush,tex[j],0,j+1
					Next
				Else
					TextureCoords bumptex,0
					For j=0 To 1
						BrushTexture brush,tex[j],0,j+2
					Next
					BrushTexture brush,bumptex,0,1
				EndIf
				BrushTexture brush,AmbientLightRoomTex,0
			Else
				If BumpEnabled
					If tex[1]<>0 Then
						temp$ = StripPath(TextureName(tex[1]))
						For mat = Each Materials
							If mat\name = temp$ Then
								bumptex = mat\Bump
								Exit
							EndIf
						Next
					EndIf
				Else
					bumptex=0
				EndIf
				If bumptex=0
					For j=0 To 1
						If tex[j]<>0
							BrushTexture brush,tex[j],0,j
						Else
							BrushTexture brush,MissingTexture,0,j
						EndIf
					Next
				Else
					TextureCoords bumptex,0
					For j=0 To 1
						If tex[j]<>0
							BrushTexture brush,tex[j],0,j+1
						Else
							BrushTexture brush,MissingTexture,0,j+1
						EndIf
					Next
					BrushTexture brush,bumptex,0,0
				EndIf
			EndIf
		EndIf
		
		;surf=CreateSurface(childMesh)
		
		If isAlpha>0 Then PaintSurface surf,brush
		
		FreeBrush brush : brush = 0
		
		count2=ReadInt(f) ;vertices
		
		For j%=1 To count2
			;world coords
			x=ReadFloat(f) : y=ReadFloat(f) : z=ReadFloat(f)
			
			vertex=AddVertex(surf,x,y,z)
			
			;texture coords
			For k%=0 To 1
				u=ReadFloat(f) : v=ReadFloat(f)
				VertexTexCoords surf,vertex,u,v,0.0,k
			Next
			
			;colors
			temp1i=ReadByte(f)
			temp2i=ReadByte(f)
			temp3i=ReadByte(f)
			VertexColor surf,vertex,temp1i,temp2i,temp3i,1.0
		Next
		
		count2=ReadInt(f) ;polys
		For j%=1 To count2
			temp1i = ReadInt(f) : temp2i = ReadInt(f) : temp3i = ReadInt(f)
			AddTriangle(surf,temp1i,temp2i,temp3i)
		Next
		
		If isAlpha=1 Then
			AddMesh childMesh,Alpha
			EntityAlpha childMesh,0.0
		Else
			AddMesh childMesh,Opaque
			EntityParent childMesh,collisionMeshes
			EntityAlpha childMesh,0.0
			EntityType childMesh,HIT_MAP
			EntityPickMode childMesh,2
			
			If doublesided Then	;make collision double-sided
				Local flipChild% = CopyMesh(childMesh)
				FlipMesh(flipChild)
				AddMesh flipChild,childMesh
				flipChild = FreeEntity_Strict(flipChild)
			EndIf
		EndIf
		HideEntity childMesh
	Next
	;[End Block]
	
	Local hiddenMesh%
	hiddenMesh=CreateMesh()
	
	count=ReadInt(f) ;invisible collision mesh
	For i%=1 To count
		surf=CreateSurface(hiddenMesh)
		count2=ReadInt(f) ;vertices
		For j%=1 To count2
			;world coords
			x=ReadFloat(f) : y=ReadFloat(f) : z=ReadFloat(f)
			vertex=AddVertex(surf,x,y,z)
		Next
		
		count2=ReadInt(f) ;polys
		For j%=1 To count2
			temp1i = ReadInt(f) : temp2i = ReadInt(f) : temp3i = ReadInt(f)
			AddTriangle(surf,temp1i,temp2i,temp3i)
			AddTriangle(surf,temp1i,temp3i,temp2i)
		Next
	Next
	
	;no coll mesh
	;[Block]
	If hasNoColl Then
		count = ReadInt(f)
		
		For i=1 To count ;drawn mesh
			childMesh=CreateMesh()
			
			surf=CreateSurface(childMesh)
			
			brush=CreateBrush()
			
			tex[0]=0 : tex[1]=0
			
			reflectiontex = 0
			
			isAlpha=0
			
			For j=0 To 1
				temp1i=ReadByte(f)
				If temp1i<>0
					temp1s=ReadString(f)
					If FileType(file+temp1s)=1 ;Check if texture is existing in original path
						If temp1i<3
							If Instr(Lower(temp1s),"_lm")<>0 Then
								tex[j]=LoadTextureCheckingIfInCache(file+temp1s,0,1+256)
							Else	
								tex[j]=LoadTextureCheckingIfInCache(file+temp1s,0,1)
							EndIf	
						Else
							tex[j]=LoadTextureCheckingIfInCache(file+temp1s,0,3)
						EndIf
					ElseIf FileType(MapTexturesFolder+temp1s)=1 ;If not, check the MapTexturesFolder
						If temp1i<3
							If Instr(Lower(temp1s),"_lm")<>0 Then
								tex[j]=LoadTextureCheckingIfInCache(MapTexturesFolder+temp1s,0,1+256)
							Else
								tex[j]=LoadTextureCheckingIfInCache(MapTexturesFolder+temp1s,0,1)
							EndIf	
						Else
							tex[j]=LoadTextureCheckingIfInCache(MapTexturesFolder+temp1s,0,3)
						EndIf
					EndIf
					If tex[j]<>0
						If temp1i=1 Then TextureBlend tex[j],5
						If Instr(Lower(temp1s),"_lm")<>0
							TextureBlend tex[j],3
						EndIf
						
						isAlpha=2
						If temp1i=3 Then isAlpha=1
						TextureCoords tex[j],1-j
					EndIf
				EndIf
			Next
			
			If isAlpha=1 Then
				If tex[1]<>0 Then
					TextureBlend tex[1],2
					BrushTexture brush,tex[1],0,0
				Else
					BrushTexture brush,MissingTexture,0,0
				EndIf
			Else
				bumptex = 0
				If tex[0]<>0 And tex[1]<>0
					If BumpEnabled
						temp$ = StripPath(TextureName(tex[1]))
						For mat = Each Materials
							If mat\name = temp$ Then
								bumptex = mat\Bump
								Exit
							EndIf
						Next
					Else
						bumptex=0
					EndIf
					If bumptex=0
						For j=0 To 1
							BrushTexture brush,tex[j],0,j+1
						Next
					Else
						TextureCoords bumptex,0
						For j=0 To 1
							BrushTexture brush,tex[j],0,j+2
						Next
						BrushTexture brush,bumptex,0,1
					EndIf
					BrushTexture brush,AmbientLightRoomTex,0
				Else
					If BumpEnabled
						If tex[1]<>0 Then
							temp$ = StripPath(TextureName(tex[1]))
							For mat = Each Materials
								If mat\name = temp$ Then
									bumptex = mat\Bump
									Exit
								EndIf
							Next
						EndIf
					Else
						bumptex=0
					EndIf
					If bumptex=0
						For j=0 To 1
							If tex[j]<>0
								BrushTexture brush,tex[j],0,j
							Else
								BrushTexture brush,MissingTexture,0,j
							EndIf
						Next
					Else
						TextureCoords bumptex,0
						For j=0 To 1
							If tex[j]<>0
								BrushTexture brush,tex[j],0,j+1
							Else
								BrushTexture brush,MissingTexture,0,j+1
							EndIf
						Next
						BrushTexture brush,bumptex,0,0
					EndIf
				EndIf
			EndIf
			
			;surf=CreateSurface(childMesh)
			
			If isAlpha>0 Then PaintSurface surf,brush
			
			FreeBrush brush : brush = 0
			
			count2=ReadInt(f) ;vertices
			
			For j%=1 To count2
				;world coords
				x=ReadFloat(f) : y=ReadFloat(f) : z=ReadFloat(f)
				
				vertex=AddVertex(surf,x,y,z)
				
				;texture coords
				For k%=0 To 1
					u=ReadFloat(f) : v=ReadFloat(f)
					VertexTexCoords surf,vertex,u,v,0.0,k
				Next
				
				;colors
				temp1i=ReadByte(f)
				temp2i=ReadByte(f)
				temp3i=ReadByte(f)
				VertexColor surf,vertex,temp1i,temp2i,temp3i,1.0
			Next
			
			count2=ReadInt(f) ;polys
			For j%=1 To count2
				temp1i = ReadInt(f) : temp2i = ReadInt(f) : temp3i = ReadInt(f)
				AddTriangle(surf,temp1i,temp2i,temp3i)
			Next
			
			If isAlpha=1 Then
				AddMesh childMesh,Alpha
				EntityAlpha childMesh,0.0
			Else
				AddMesh childMesh,Opaque
				EntityAlpha childMesh,0.0
				EntityParent childMesh,collisionMeshes ;Even if this seems odd, they still need to be parented to this pivot in order to be pickable
				EntityPickMode childMesh,2
			EndIf
			HideEntity childMesh
		Next
	EndIf
	;[End Block]
	
	;trigger boxes
	;[Block]
	If hasTriggerBox
		;debuglog "TriggerBoxEnable"
		If (Not MainMenuOpen) Then
			rt\TempTriggerboxAmount = ReadInt(f)
			For tb = 0 To rt\TempTriggerboxAmount-1
				rt\TempTriggerbox[tb] = CreateMesh(rt\obj)
				count = ReadInt(f)
				For i%=1 To count
					surf=CreateSurface(rt\TempTriggerbox[tb])
					count2=ReadInt(f)
					For j%=1 To count2
						x=ReadFloat(f) : y=ReadFloat(f) : z=ReadFloat(f)
						vertex=AddVertex(surf,x,y,z)
					Next
					count2=ReadInt(f)
					For j%=1 To count2
						temp1i = ReadInt(f) : temp2i = ReadInt(f) : temp3i = ReadInt(f)
						AddTriangle(surf,temp1i,temp2i,temp3i)
						AddTriangle(surf,temp1i,temp3i,temp2i)
					Next
				Next
				rt\TempTriggerboxName[tb] = ReadString(f)
			Next
		Else
			For tb = 0 To ReadInt(f)-1
				For i%=1 To ReadInt(f)
					For j%=1 To ReadInt(f)
						ReadFloat(f)
						ReadFloat(f)
						ReadFloat(f)
					Next
					For j%=1 To ReadInt(f)
						ReadInt(f)
						ReadInt(f)
						ReadInt(f)
					Next
				Next
			Next
		EndIf
	EndIf
	;[End Block]
	
	Local range#,lcolor$,intensity#,r%,g%,b%,angles$,pitch#,innercone%,outercone%
	Local Position.Vector3D, Rotation.Vector3D, Scale.Vector3D
	Local sfx%,sfxrange#,id%,file_handle$,ptype%,angle%
	count=ReadInt(f) ;point entities
	For i%=1 To count
		temp1s=ReadString(f)
		Select temp1s
			Case "screen"
				;[Block]
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				temp2s$ =ReadString(f)
				
				If gopt\GameMode <> GAMEMODE_MULTIPLAYER And (Not MainMenuOpen) Then
					If temp1<>0 Lor temp2<>0 Lor temp3<>0 Then 
						Local ts.TempScreens = New TempScreens	
						ts\x = temp1
						ts\y = temp2
						ts\z = temp3
						ts\imgpath = temp2s
						ts\roomtemplate = rt
					EndIf
				EndIf
				;[End Block]
			Case "waypoint"
				;[Block]
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				
				If (Not MainMenuOpen) And gopt\GameMode <> GAMEMODE_MULTIPLAYER Then
					Local w.TempWayPoints = New TempWayPoints
					w\roomtemplate = rt
					w\x = temp1
					w\y = temp2
					w\z = temp3
				ElseIf (Not MainMenuOpen) Then
					Local wa.WayPoints = CreateMPWaypoint(temp1,temp2,temp3)
				EndIf
				;[End Block]
			Case "light"
				;[Block]
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				
				If temp1<>0 Lor temp2<>0 Lor temp3<>0 Then 
					range# = ReadFloat(f)/2000.0
					lcolor$=ReadString(f)
					intensity# = Min(ReadFloat(f)*0.8,1.0)
					r%=Int(Piece(lcolor,1," "))*intensity
					g%=Int(Piece(lcolor,2," "))*intensity
					b%=Int(Piece(lcolor,3," "))*intensity
					
					If (Not MainMenuOpen) And gopt\GameMode <> GAMEMODE_MULTIPLAYER Then
						AddTempLight(rt, temp1,temp2,temp3, 2, range, r,g,b)
					ElseIf (Not MainMenuOpen) And gopt\GameMode = GAMEMODE_MULTIPLAYER Then
						AddLightMPMap(mp_I\Map,temp1,temp2,temp3,2,range,r,g,b)
					ElseIf MainMenuOpen Then
						AddLightMenu3D(temp1,temp2,temp3,2,range,r,g,b)
					EndIf
				Else
					ReadFloat(f) : ReadString(f) : ReadFloat(f)
				EndIf
				;[End Block]
			Case "spotlight"
				;[Block]
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				
				If temp1<>0 Lor temp2<>0 Lor temp3<>0 Then 
					range# = ReadFloat(f)/2000.0
					lcolor$=ReadString(f)
					intensity# = Min(ReadFloat(f)*0.8,1.0)
					r%=Int(Piece(lcolor,1," "))*intensity
					g%=Int(Piece(lcolor,2," "))*intensity
					b%=Int(Piece(lcolor,3," "))*intensity
					angles$=ReadString(f)
					pitch#=Piece(angles,1," ")
					yaw#=Piece(angles,2," ")
					innercone = ReadInt(f)
					outercone = ReadInt(f)
					
					If (Not MainMenuOpen) And gopt\GameMode <> GAMEMODE_MULTIPLAYER Then
						Local lt.LightTemplates = AddTempLight(rt, temp1,temp2,temp3, 2, range, r,g,b)
						lt\pitch = pitch
						lt\yaw = yaw
						lt\innerconeangle = innercone
						lt\outerconeangle = outercone
					ElseIf (Not MainMenuOpen) And gopt\GameMode = GAMEMODE_MULTIPLAYER Then
						AddLightMPMap(mp_I\Map,temp1,temp2,temp3,3,range,r,g,b)
						RotateEntity mp_I\Map\Lights[mp_I\Map\LightAmount-1],pitch,yaw,0
						LightConeAngles(mp_I\Map\Lights[mp_I\Map\LightAmount-1],innercone,outercone)
					ElseIf MainMenuOpen Then
						Local ml.Menu3DLights = AddLightMenu3D(temp1,temp2,temp3,3,range,r,g,b)
						RotateEntity ml\Lights,pitch,yaw,0
						LightConeAngles ml\Lights,innercone,outercone
					EndIf
				Else
					ReadFloat(f) : ReadString(f) : ReadFloat(f) : ReadString(f) : ReadInt(f) : ReadInt(f)
				EndIf
				;[End Block]
			Case "soundemitter"
				;[Block]
				temp1i=0
				
				If (Not MainMenuOpen) And gopt\GameMode <> GAMEMODE_MULTIPLAYER Then
					If rt<>Null Then
						For j = 0 To MaxRoomEmitters-1
							If rt\TempSoundEmitter[j]=0 Then
								rt\TempSoundEmitterX[j]=ReadFloat(f)*RoomScale
								rt\TempSoundEmitterY[j]=ReadFloat(f)*RoomScale
								rt\TempSoundEmitterZ[j]=ReadFloat(f)*RoomScale
								rt\TempSoundEmitter[j]=ReadInt(f)
								
								rt\TempSoundEmitterRange[j]=ReadFloat(f)
								temp1i=1
								Exit
							EndIf
						Next
					EndIf
				ElseIf (Not MainMenuOpen) And gopt\GameMode = GAMEMODE_MULTIPLAYER Then
					temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
					Position = CreateVector3D(temp1*RoomScale, temp2*RoomScale, temp3*RoomScale)
					
					sfx = ReadInt(f)
					sfxrange = ReadFloat(f)
					
					Local se.SoundEmittor = CreateSoundEmittor(Position, sfx, sfxrange)
					temp1i=1
				EndIf
				
				If temp1i=0 Then
					ReadFloat(f)
					ReadFloat(f)
					ReadFloat(f)
					ReadInt(f)
					ReadFloat(f)
				EndIf
				;[End Block]
			Case "model", "model_nocoll"
				;[Block]
				file = ReadString(f)
				If file<>""
					Local model = CreatePropObj("GFX\Map\props\"+file)
					
					temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
					PositionEntity model,temp1,temp2,temp3
					
					temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
					RotateEntity model,temp1,temp2,temp3
					
					temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
					ScaleEntity model,temp1,temp2,temp3
					
					EntityParent model,Opaque
					If temp1s <> "model_nocoll" Then
						EntityType model,HIT_MAP
					Else
						EntityType model,0
					EndIf
					EntityPickMode model,2
				Else
					;debuglog "file = 0"
					temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
					;debuglog temp1+", "+temp2+", "+temp3
				EndIf
				;[End Block]
			Case "fusebox", "generator"
				;[Block]
				file = ReadString(f)
				
				If temp1s = "generator" Then
					sfx = ReadInt(f)
					sfxrange = ReadFloat(f)
					id = ReadInt(f)
				EndIf
				
				;TODO: Make it so the 180 will be removed (for the additional yaw rotation)!
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Position = CreateVector3D(temp1*RoomScale, temp2*RoomScale, temp3*RoomScale)
				
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Rotation = CreateVector3D(temp1, temp2+(180*(temp1s = "fusebox")), temp3)
				
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Scale = CreateVector3D(temp1*RoomScale, temp2*RoomScale, temp3*RoomScale)
				
				If temp1s = "fusebox" Then
					Local fb.FuseBox = CreateFuseBox(file, Position, Rotation, Scale)
				Else
					Local ge.Generator = CreateGenerator(file, Position, Rotation, Scale, sfx, sfxrange, id)
				EndIf
				;[End Block]
			Case "button_gen", "lever_gen"
				;[Block]
				file = ReadString(f)
				
				If temp1s = "lever_gen" Then
					file_handle = ReadString(f)
					angle = ReadInt(f) 
				EndIf
				
				id = ReadInt(f)
				
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Position = CreateVector3D(temp1*RoomScale, temp2*RoomScale, temp3*RoomScale)
				
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Rotation = CreateVector3D(temp1, temp2, temp3)
				
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Scale = CreateVector3D(temp1*RoomScale, temp2*RoomScale, temp3*RoomScale)
				
				If temp1s = "lever_gen" Then
					Local lg.LeverGen = CreateLeverGen(file, file_handle, Position, Rotation, Scale, angle, id)
				Else
					Local bg.ButtonGen = CreateButtonGen(file, Position, Rotation, Scale, id)
				EndIf
				;[End block]
			Case "particle_gen"	
				;[Block]
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Position = CreateVector3D(temp1*RoomScale, temp2*RoomScale, temp3*RoomScale)
				
				ptype = ReadByte(f)
				angles$=ReadString(f)
				pitch#=Piece(angles,1," ")
				yaw#=Piece(angles,2," ")
				id = ReadInt(f)
				
				Local pg.ParticleGen = CreateParticleGen(Position, ptype, pitch, yaw, id)
				;[End block]
			Case "mp_damageboss_radius"	
				;[Block]
				temp1=ReadFloat(f) : temp2=ReadFloat(f) : temp3=ReadFloat(f)
				Position = CreateVector3D(temp1*RoomScale, temp2*RoomScale, temp3*RoomScale)
				
				range = ReadFloat(f)
				id = ReadInt(f)
				
				Local dbr.DamageBossRadius = CreateDamageBossRadius(Position,range,id)
				;[End block]
			Case "mp_playerspawn"
				;[Block]
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				Local team% = ReadByte(f)
				yaw = ReadFloat(f)
				If mp_I\PlayState = GAME_SERVER Then
					Local pls.PlayerSpawner = CreatePlayerSpawner(temp1,temp2,temp3,yaw,team)
				EndIf
				;[End Block]
			Case "mp_enemyspawn"
				;[Block]
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				Local enemyString$=ReadString(f)
				
				If mp_I\PlayState = GAME_SERVER Then
					Local ens.EnemySpawner = CreateEnemySpawner(temp1,temp2,temp3,enemyString)
				EndIf
				;[End Block]
			Case "mp_itemspawn"
				;[Block]
				temp1=ReadFloat(f)*RoomScale
				temp2=ReadFloat(f)*RoomScale
				temp3=ReadFloat(f)*RoomScale
				Local ittype = ReadByte(f)
				Local respawntime = ReadInt(f)
				Local rndtime$ = ReadString(f)
				Local rndtime1 = Piece(rndtime,1," ")
				Local rndtime2 = Piece(rndtime,2," ")
				
				If mp_I\PlayState = GAME_SERVER Then
					Local its.ItemSpawner = CreateItemSpawner(temp1,temp2,temp3,ittype,respawntime,rndtime1,rndtime2)
				EndIf
				;[End Block]
;			Case "flu_light"
;				;[Block]
;				Local tfll.TempFluLight = New TempFluLight
;				tfll\roomtemplate = rt
;				temp1=ReadFloat(f)*RoomScale
;				temp2=ReadFloat(f)*RoomScale
;				temp3=ReadFloat(f)*RoomScale
;				tfll\position = CreateVector3D(temp1,temp2,temp3)
;				temp1=ReadFloat(f)
;				temp2=ReadFloat(f)
;				temp3=ReadFloat(f)
;				tfll\rotation = CreateVector3D(temp1,temp2,temp3)
;				tfll\id = ReadInt(f)
;				
;				;debuglog "FLU LIGHT DETECTED!"
;				;[End Block]
				
			Case "flu_light"
				;[Block]
				Local tfll.TempFluLight = New TempFluLight
				tfll\roomtemplate = rt
				
				; ~ Load coords
				temp1 = ReadFloat(f) * RoomScale : temp2 = ReadFloat(f) * RoomScale : temp3 = ReadFloat(f) * RoomScale
				tfll\position = CreateVector3D(temp1, temp2, temp3)
				
				; ~ Load rotation
				temp1 = ReadFloat(f) : temp2 = ReadFloat(f) : temp3 = ReadFloat(f)
				tfll\rotation = CreateVector3D(temp1, temp2, temp3)
				
				; ~ Detect ID
				tfll\id = ReadInt(f)
				
				;debuglog("FLU LIGHT DETECTED!")
				;[End Block]
		End Select
	Next
	
	Local obj%
	
	temp1i=CopyMesh(Alpha)
	FlipMesh temp1i
	AddMesh temp1i,Alpha
	temp1i = FreeEntity_Strict(temp1i)
	
	If brush <> 0 Then FreeBrush brush
	
	AddMesh Alpha,Opaque
	Alpha = FreeEntity_Strict(Alpha)
	
	EntityFX Opaque,3
	
	EntityAlpha hiddenMesh,0.0
	EntityAlpha Opaque,1.0
	
	EntityType hiddenMesh,HIT_MAP
	
	obj=CreatePivot()
	CreatePivot(obj) ;skip "meshes" object
	EntityParent Opaque,obj
	EntityParent hiddenMesh,obj
	CreatePivot(obj) ;skip "pointentites" object
	CreatePivot(obj) ;skip "solidentites" object
	EntityParent collisionMeshes,obj
	
	CloseFile f
	
	CatchErrors("LoadRMesh")
	Return obj%
	
End Function

;------------------------------------

Function StripPath$(file$) 
	Local name$=""
	If Len(file$)>0 
		For i=Len(file$) To 1 Step -1 
			
			midd$=Mid$(file$,i,1) 
			If midd$="\" Lor midd$="/" Then Return name$
			
			name$=midd$+name$
		Next 
		
	EndIf 
	
	Return name$ 
End Function

Function Piece$(s$,entry,char$=" ")
	While Instr(s,char+char)
		s=Replace(s,char+char,char)
	Wend
	For n=1 To entry-1
		p=Instr(s,char)
		s=Right(s,Len(s)-p)
	Next
	p=Instr(s,char)
	If p<1
		a$=s
	Else
		a=Left(s,p-1)
	EndIf
	Return a
End Function

Function KeyValue$(entity,key$,defaultvalue$="")
	properties$=EntityName(entity)
	properties$=Replace(properties$,Chr(13),"")
	key$=Lower(key)
	Repeat
		p=Instr(properties,Chr(10))
		If p Then test$=(Left(properties,p-1)) Else test=properties
		testkey$=Piece(test,1,"=")
		testkey=Trim(testkey)
		testkey=Replace(testkey,Chr(34),"")
		testkey=Lower(testkey)
		If testkey=key Then
			value$=Piece(test,2,"=")
			value$=Trim(value$)
			value$=Replace(value$,Chr(34),"")
			Return value
		EndIf
		If Not p Then Return defaultvalue$
		properties=Right(properties,Len(properties)-p)
	Forever 
End Function


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;Forest gen consts
Const gridsize% = 10
Const deviation_chance% = 40 ;out of 100
Const branch_chance% = 65
Const branch_max_life% = 4
Const branch_die_chance% = 18
Const max_deviation_distance% = 3
Const return_chance% = 27
Const center = 5 ;(gridsize-1) / 2

Type Forest
	Field TileMesh%[6]
	Field DetailMesh%[6]
	Field grid%[(gridsize*gridsize)+11]
	Field TileEntities%[(gridsize*gridsize)+1]
	Field Forest_Pivot%
	
	Field Door%[2]
	Field DetailEntities%[2]
	
	Field ID%
End Type

Function move_forward%(dir%,pathx%,pathy%,retval%=0)
	;move 1 unit along the grid in the designated direction
	If dir = 1 Then
		If retval=0 Then
			Return pathx
		Else
			Return pathy+1
		EndIf
	EndIf
	If retval=0 Then
		Return pathx-1+dir
	Else
		Return pathy
	EndIf
End Function

Function chance%(chanc%)
	;perform a chance given a probability
	Return (Rand(0,100)<=chanc)
End Function

Function turn_if_deviating%(max_deviation_distance_%,pathx%,center_%,dir%,retval%=0)
	;check if deviating and return the answer. if deviating, turn around
	Local current_deviation% = center_ - pathx
	Local deviated% = False
	If (dir = 0 And current_deviation >= max_deviation_distance_) Lor (dir = 2 And current_deviation <= -max_deviation_distance_) Then
		dir = (dir + 2) Mod 4
		deviated = True
	EndIf
	If retval=0 Then Return dir Else Return deviated
End Function

Function GenForestGrid(fr.Forest)
	CatchErrors("Uncaught (GenForestGrid)")
	fr\ID=LastForestID+1
	LastForestID=LastForestID+1
	
	Local door1_pos%,door2_pos%
	Local i%,j%
	door1_pos=Rand(3,7)
	door2_pos=Rand(3,7)
	
	;clear the grid
	For i=0 To gridsize-1
		For j=0 To gridsize-1
			fr\grid[(j*gridsize)+i]=0
		Next
	Next
	
	;set the position of the concrete and doors
	;For i=0 To gridsize-1
	;	fr\grid[i]=2
	;	fr\grid[((gridsize-1)*gridsize)+i]=2
	;Next
	fr\grid[door1_pos]=3
	fr\grid[((gridsize-1)*gridsize)+door2_pos]=3
	
	;generate the path
	Local pathx = door2_pos
	Local pathy = 1
	Local dir = 1 ;0 = left, 1 = up, 2 = right
	fr\grid[((gridsize-1-pathy)*gridsize)+pathx] = 1
	
	Local deviated%
	
	While pathy < gridsize -4
		If dir = 1 Then ;determine whether to go forward or to the side
			If chance(deviation_chance) Then
				;pick a branch direction
				dir = 2 * Rand(0,1)
				;make sure you have not passed max side distance
				dir = turn_if_deviating(max_deviation_distance,pathx,center,dir)
				deviated = turn_if_deviating(max_deviation_distance,pathx,center,dir,1)
				If deviated Then fr\grid[((gridsize-1-pathy)*gridsize)+pathx]=1
				pathx=move_forward(dir,pathx,pathy)
				pathy=move_forward(dir,pathx,pathy,1)
			EndIf
			
		Else
			;we are going to the side, so determine whether to keep going or go forward again
			dir = turn_if_deviating(max_deviation_distance,pathx,center,dir)
			deviated = turn_if_deviating(max_deviation_distance,pathx,center,dir,1)
			If deviated Lor chance(return_chance) Then dir = 1
			
			pathx=move_forward(dir,pathx,pathy)
			pathy=move_forward(dir,pathx,pathy,1)
			;if we just started going forward go twice so as to avoid creating a potential 2x2 line
			If dir=1 Then
				fr\grid[((gridsize-1-pathy)*gridsize)+pathx]=1
				pathx=move_forward(dir,pathx,pathy)
				pathy=move_forward(dir,pathx,pathy,1)
			EndIf
		EndIf
		
		;add our position to the grid
		fr\grid[((gridsize-1-pathy)*gridsize)+pathx]=1
		
	Wend
	;finally, bring the path back to the door now that we have reached the end
	dir = 1
	While pathy < gridsize-2
		pathx=move_forward(dir,pathx,pathy)
		pathy=move_forward(dir,pathx,pathy,1)
		fr\grid[((gridsize-1-pathy)*gridsize)+pathx]=1
	Wend
	
	If pathx<>door1_pos Then
		dir=0
		If door1_pos>pathx Then dir=2
		While pathx<>door1_pos
			pathx=move_forward(dir,pathx,pathy)
			pathy=move_forward(dir,pathx,pathy,1)
			fr\grid[((gridsize-1-pathy)*gridsize)+pathx]=1
		Wend
	EndIf
	
	;attempt to create new branches
	Local new_y%,temp_y%,new_x%
	Local branch_type%,branch_pos%
	new_y=-3 ;used for counting off; branches will only be considered once every 4 units so as to avoid potentially too many branches
	While new_y<gridsize-6
		new_y=new_y+4
		temp_y=new_y
		new_x=0
		If chance(branch_chance) Then
			branch_type=-1
			If chance(cobble_chance) Then
				branch_type=-2
			EndIf
			;create a branch at this spot
			;determine if on left or on right
			branch_pos=2*Rand(0,1)
			;get leftmost or rightmost path in this row
			leftmost=gridsize
			rightmost=0
			For i=0 To gridsize
				If fr\grid[((gridsize-1-new_y)*gridsize)+i]=1 Then
					If i<leftmost Then leftmost=i
					If i>rightmost Then rightmost=i
				EndIf
			Next
			If branch_pos=0 Then new_x=leftmost-1 Else new_x=rightmost+1
			;before creating a branch make sure there are no 1's above or below
			If (temp_y<>0 And fr\grid[((gridsize-1-temp_y+1)*gridsize)+new_x]=1) Lor fr\grid[((gridsize-1-temp_y-1)*gridsize)+new_x]=1 Then
				Exit ;break simply to stop creating the branch
			EndIf
			fr\grid[((gridsize-1-temp_y)*gridsize)+new_x]=branch_type ;make 4s so you don't confuse your branch for a path; will be changed later
			If branch_pos=0 Then new_x=leftmost-2 Else new_x=rightmost+2
			fr\grid[((gridsize-1-temp_y)*gridsize)+new_x]=branch_type ;branch out twice to avoid creating an unwanted 2x2 path with the real path
			i = 2
			While i<branch_max_life
				i=i+1
				If chance(branch_die_chance) Then
					Exit
				EndIf
				If Rand(0,3)=0 Then ;have a higher chance to go up to confuse the player
					If branch_pos = 0 Then
						new_x=new_x-1
					Else
						new_x=new_x+1
					EndIf
				Else
					temp_y=temp_y+1
				EndIf
				
				;before creating a branch make sure there are no 1's above or below
				n=((gridsize - 1 - temp_y + 1)*gridsize)+new_x
				If n < gridsize-1 Then 
					If temp_y <> 0 And fr\grid[n]=1 Then Exit
				EndIf
				n=((gridsize - 1 - temp_y - 1)*gridsize)+new_x
				If n>0 Then 
					If fr\grid[n]=1 Then Exit
				EndIf
				
				;If (temp_y <> 0 And fr\grid[((gridsize - 1 - temp_y + 1)*gridsize)+new_x]=1) Lor fr\grid[((gridsize - 1 - temp_y - 1)*gridsize)+new_x] = 1 Then
				;	Exit
				;EndIf
				fr\grid[((gridsize-1-temp_y)*gridsize)+new_x]=branch_type ;make 4s so you don't confuse your branch for a path; will be changed later
				If temp_y>=gridsize-2 Then Exit
			Wend
		EndIf
	Wend
	
	;change branches from 4s to 1s (they were 4s so that they didn't accidently create a 2x2 path unintentionally)
	For i=0 To gridsize-1
		For j=0 To gridsize-1
			If fr\grid[(i*gridsize)+j]=-1 Then
				fr\grid[(i*gridsize)+j]=1
			ElseIf fr\grid[(i*gridsize)+j]=-2
				fr\grid[(i*gridsize)+j]=1
			;ElseIf fr\grid[(i*gridsize)+j]=0
				
			EndIf
		Next
	Next
	
	CatchErrors("GenForestGrid")
End Function

Function PlaceForest(fr.Forest,x#,y#,z#,r.Rooms)
	CatchErrors("Uncaught (PlaceForest)")
	;local variables
	Local tx%,ty%
	Local tile_size#=12.0
	Local tile_type%
	Local tile_entity%,detail_entity%
	
	Local tempf1#,tempf2#,tempf3#
	Local i%
	
	fr\Forest_Pivot = FreeEntity_Strict(fr\Forest_Pivot)
	For i%=0 To 3
		fr\TileMesh[i] = FreeEntity_Strict(fr\TileMesh[i])
	Next
	For i%=0 To 4
		fr\DetailMesh[i] = FreeEntity_Strict(fr\DetailMesh[i])
	Next
	
	fr\Forest_Pivot=CreatePivot()
	PositionEntity fr\Forest_Pivot,x,y,z,True
	
	;load assets
	
	Local hmap[6], mask[6]
	Local GroundTexture = LoadTexture_Strict("GFX\map\textures\forestfloor.jpg",256)
	Local PathTexture = LoadTexture_Strict("GFX\map\textures\forestpath.jpg",256)
	
	hmap[ROOM1]=LoadImage_Strict("GFX\map\forest\forest1h.png")
	mask[ROOM1]=LoadTexture_Strict("GFX\map\forest\forest1h_mask.png",1+2+256)
	
	hmap[ROOM2]=LoadImage_Strict("GFX\map\forest\forest2h.png")
	mask[ROOM2]=LoadTexture_Strict("GFX\map\forest\forest2h_mask.png",1+2+256)
	
	hmap[ROOM2C]=LoadImage_Strict("GFX\map\forest\forest2Ch.png")
	mask[ROOM2C]=LoadTexture_Strict("GFX\map\forest\forest2Ch_mask.png",1+2+256)
	
	hmap[ROOM3]=LoadImage_Strict("GFX\map\forest\forest3h.png")
	mask[ROOM3]=LoadTexture_Strict("GFX\map\forest\forest3h_mask.png",1+2+256)
	
	hmap[ROOM4]=LoadImage_Strict("GFX\map\forest\forest4h.png")
	mask[ROOM4]=LoadTexture_Strict("GFX\map\forest\forest4h_mask.png",1+2+256)
	
	For i = ROOM1 To ROOM4
		fr\TileMesh[i]=load_terrain(hmap[i],0.03,GroundTexture,PathTexture,mask[i])
	Next
	
	;detail meshes
	;fr\DetailMesh[0]=LoadMesh_strict("GFX\map\forest\detail\860_1_tree1.b3d")
	;fr\DetailMesh[1]=LoadMesh_strict("GFX\map\forest\detail\860_1_tree1_leaves.b3d")
	fr\DetailMesh[1]=LoadMesh_Strict("GFX\map\forest\detail\treetest4.b3d");1.b3d)
	;EntityParent fr\DetailMesh[1],fr\DetailMesh[0]
	fr\DetailMesh[2]=LoadMesh_Strict("GFX\map\forest\detail\rock.b3d")
	fr\DetailMesh[3]=LoadMesh_Strict("GFX\map\forest\detail\rock2.b3d")
	fr\DetailMesh[4]=LoadMesh_Strict("GFX\map\forest\detail\treetest5.b3d")
	fr\DetailMesh[5]=LoadRMesh("GFX\map\forest\wall_opt.rmesh",Null)
	
	For i%=ROOM1 To ROOM4
		HideEntity fr\TileMesh[i]
	Next
	For i%=1 To 5
		HideEntity fr\DetailMesh[i]
	Next
	
	tempf3=MeshWidth(fr\TileMesh[ROOM1])
	tempf1=tile_size/tempf3
	
	For tx%=0 To gridsize-1
		For ty%=0 To gridsize-1
			If fr\grid[(ty*gridsize)+tx]=1 Then 
				
				tile_type = 0
				If tx+1<gridsize Then tile_type = (fr\grid[(ty*gridsize)+tx+1]>0)
				If tx-1=>0 Then tile_type = tile_type+(fr\grid[(ty*gridsize)+tx-1]>0)
				
				If ty+1<gridsize Then tile_type = tile_type+(fr\grid[((ty+1)*gridsize)+tx]>0)
				If ty-1=>0 Then tile_type = tile_type+(fr\grid[((ty-1)*gridsize)+tx]>0)
				
				;fr\grid[(ty*gridsize)+tx]=tile_type
				
				Local angle%=0
				Select tile_type
					Case 1
						tile_entity = CopyEntity(fr\TileMesh[ROOM1])
						
						If fr\grid[((ty+1)*gridsize)+tx]>0 Then
							angle = 180
						ElseIf fr\grid[(ty*gridsize)+tx-1]>0
							angle = 270
						ElseIf fr\grid[(ty*gridsize)+tx+1]>0
							angle = 90
						End If
						
						tile_type = ROOM1
					Case 2
						If fr\grid[((ty-1)*gridsize)+tx]>0 And fr\grid[((ty+1)*gridsize)+tx]>0 Then
							tile_entity = CopyEntity(fr\TileMesh[ROOM2])
							tile_type = ROOM2
						ElseIf fr\grid[(ty*gridsize)+tx+1]>0 And fr\grid[(ty*gridsize)+tx-1]>0
							tile_entity = CopyEntity(fr\TileMesh[ROOM2])
							angle = 90
							tile_type = ROOM2
						Else
							tile_entity = CopyEntity(fr\TileMesh[ROOM2C])
							If fr\grid[(ty*gridsize)+tx-1]>0 And fr\grid[((ty+1)*gridsize)+tx]>0 Then
								angle = 180
							ElseIf fr\grid[(ty*gridsize)+tx+1]>0 And fr\grid[((ty-1)*gridsize)+tx]>0
								
							ElseIf fr\grid[(ty*gridsize)+tx-1]>0 And fr\grid[((ty-1)*gridsize)+tx]>0
								angle = 270
							Else
								angle = 90
							EndIf
							tile_type = ROOM2C
						EndIf
					Case 3
						tile_entity = CopyEntity(fr\TileMesh[ROOM3])
						
						If fr\grid[((ty-1)*gridsize)+tx]=0 Then
							angle = 180
						ElseIf fr\grid[(ty*gridsize)+tx-1]=0
							angle = 90
						ElseIf fr\grid[(ty*gridsize)+tx+1]=0
							angle = 270
						End If
						
						tile_type = ROOM3
					Case 4
						tile_entity = CopyEntity(fr\TileMesh[ROOM4])	
						tile_type = ROOM4
					Default 
						;debuglog "tile_type: "+tile_type
				End Select
				
				If tile_type > 0 Then 
					
					Local itemPlaced[4]
					;2, 5, 8
					Local it.Items = Null
					If (ty Mod 3)=2 And itemPlaced[Floor(ty/3)]=False Then
						itemPlaced[Floor(ty/3)]=True
						;it.Items = CreateItem("Log #"+Int(Floor(ty/3)+1), "paper", 0,0.5,0)
						;EntityType(it\collider, HIT_ITEM)
						;EntityParent(it\collider, tile_entity)
					EndIf
					
					;place trees and other details
					;only placed on spots where the value of the heightmap is above 100
					SetBuffer ImageBuffer(hmap[tile_type])
					width = ImageWidth(hmap[tile_type])
					tempf4# = (tempf3/Float(width))
					For lx = 3 To width-2
						For ly = 3 To width-2
							GetColor lx,width-ly
							
							If ColorRed()>Rand(100,260) Then
								Select Rand(0,7)
									Case 0,1,2,3,4,5,6 ;create a tree
										detail_entity=CopyEntity(fr\DetailMesh[1])
										;EntityType detail_entity,HIT_MAP
										tempf2=Rnd(0.25,0.4)
										
										For i = 0 To 3
											d=CopyEntity(fr\DetailMesh[4])
											;ScaleEntity d,tempf2*1.1,tempf2,tempf2*1.1,True
											RotateEntity d, 0, 90*i+Rnd(-20,20), 0
											EntityParent(d,detail_entity)
											
											EntityFX d, 1;+8
										Next
										
										ScaleEntity detail_entity,tempf2*1.1,tempf2,tempf2*1.1,True
										PositionEntity detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-Rnd(3.0,3.2),ly*tempf4-(tempf3/2.0),True
										
										RotateEntity detail_entity,Rnd(-5,5),Rnd(360.0),0.0,True
										
										;EntityAutoFade(detail_entity,4.0,6.0)
									Case 7 ;add a rock
										detail_entity=CopyEntity(fr\DetailMesh[2])
										;EntityType detail_entity,HIT_MAP
										tempf2=Rnd(0.01,0.012)
										;ScaleEntity detail_entity,tempf2,tempf2*Rnd(1.0,2.0),tempf2,True
										
										PositionEntity detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-1.3,ly*tempf4-(tempf3/2.0),True
										
										EntityFX detail_entity, 1
										
										RotateEntity detail_entity,0.0,Rnd(360.0),0.0,True
									Case 6 ;add a stump
										detail_entity=CopyEntity(fr\DetailMesh[4])
										;EntityType detail_entity,HIT_MAP
										tempf2=Rnd(0.1,0.12)
										ScaleEntity detail_entity,tempf2,tempf2,tempf2,True
										
										PositionEntity detail_entity,lx*tempf4-(tempf3/2.0),ColorRed()*0.03-1.3,ly*tempf4-(tempf3/2.0),True
								End Select
								
								EntityFX detail_entity, 1
								;PositionEntity detail_entity,Rnd(0.0,tempf3)-(tempf3/2.0),ColorRed()*0.03-0.05,Rnd(0.0,tempf3)-(tempf3/2.0),True
								EntityParent detail_entity,tile_entity
							EndIf
						Next
					Next
					SetBuffer BackBuffer()
					
					TurnEntity tile_entity, 0, angle, 0
					
					PositionEntity tile_entity,x+(tx*tile_size),y,z+(ty*tile_size),True
					
					ScaleEntity tile_entity,tempf1,tempf1,tempf1
					EntityType tile_entity,HIT_MAP
					EntityFX tile_entity,1
					EntityParent tile_entity,fr\Forest_Pivot
					EntityPickMode tile_entity,2
					
					If it<>Null Then EntityParent it\collider,0
					
					fr\TileEntities[tx+(ty*gridsize)] = tile_entity
				Else
					;debuglog "INVALID TILE @ ("+tx+", "+ty+ "): "+tile_type
				EndIf
			EndIf
			
		Next
	Next
	
	;place the wall		
	For i = 0 To 1
		ty = ((gridsize-1)*i)
		
		For tx = 1 To gridsize-1
			If fr\grid[(ty*gridsize)+tx]=3 Then
				fr\DetailEntities[i]=CopyEntity(fr\DetailMesh[5])
				ScaleEntity fr\DetailEntities[i],RoomScale,RoomScale,RoomScale
				
				fr\Door[i] = CopyEntity(r\Objects[3])
				PositionEntity fr\Door[i],72*RoomScale,32.0*RoomScale,0,True
				RotateEntity fr\Door[i], 0,180,0
				ScaleEntity fr\Door[i],48*RoomScale,45*RoomScale,48*RoomScale,True
				EntityParent fr\Door[i],fr\DetailEntities[i]
				;SetAnimTime fr\Door[i], 0
				
				frame = CopyEntity(r\Objects[2],fr\Door[i])
				PositionEntity frame,0,32.0*RoomScale,0,True
				ScaleEntity frame,48*RoomScale,45*RoomScale,48*RoomScale,True
				EntityParent frame,fr\DetailEntities[i]
				
				EntityType fr\DetailEntities[i],HIT_MAP
				;EntityParent frame,fr\DetailEntities[i]
				EntityPickMode fr\DetailEntities[i],2
				
				PositionEntity fr\DetailEntities[i],x+(tx*tile_size),y,z+(ty*tile_size)+(tile_size/2)-(tile_size*i),True
				RotateEntity fr\DetailEntities[i],0,180*i,0
				
				EntityParent fr\DetailEntities[i],fr\Forest_Pivot
			EndIf		
		Next		
	Next
	
	CatchErrors("PlaceForest")
End Function

Function DestroyForest(fr.Forest)
	CatchErrors("Uncaught (DestroyForest)")
	Local i%
	Local tx%,ty%
	
	For tx% = 0 To gridsize-1
		For ty% = 0 To gridsize-1
			If fr\TileEntities[tx+(ty*gridsize)]<>0 Then
				fr\TileEntities[tx+(ty*gridsize)] = FreeEntity_Strict(fr\TileEntities[tx+(ty*gridsize)])
				fr\grid[tx+(ty*gridsize)] = 0
			EndIf
		Next
	Next
	For i = 0 To 1
		fr\Door[i] = FreeEntity_Strict(fr\Door[i])
		fr\DetailEntities[i] = FreeEntity_Strict(fr\DetailEntities[i])
	Next
	
	fr\Forest_Pivot = FreeEntity_Strict(fr\Forest_Pivot)
	For i%=0 To 3
		fr\TileMesh[i] = FreeEntity_Strict(fr\TileMesh[i])
	Next
	For i%=0 To 4
		fr\DetailMesh[i] = FreeEntity_Strict(fr\DetailMesh[i])
	Next
	
	CatchErrors("DestroyForest")
End Function


Function UpdateForest(fr.Forest,ent%)
	CatchErrors("Uncaught (UpdateForest)")
	;local variables
	Local tx%,ty%
	If Abs(EntityY(ent,True)-EntityY(fr\Forest_Pivot,True))<12.0 Then
		For tx% = 0 To gridsize-1
			For ty% = 0 To gridsize-1
				If fr\TileEntities[tx+(ty*gridsize)]<>0 Then
					If Abs(EntityX(ent,True)-EntityX(fr\TileEntities[tx+(ty*gridsize)],True))<20.0 Then
						If Abs(EntityZ(ent,True)-EntityZ(fr\TileEntities[tx+(ty*gridsize)],True))<20.0 Then
							ShowEntity fr\TileEntities[tx+(ty*gridsize)]
						Else
							HideEntity fr\TileEntities[tx+(ty*gridsize)]
						EndIf
					Else
						HideEntity fr\TileEntities[tx+(ty*gridsize)]
					EndIf
				EndIf
			Next
		Next
	EndIf
	CatchErrors("UpdateForest")
End Function

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Global RoomTempID%

Type RoomTemplates
	Field obj%, id%
	Field objPath$
	
	Field zone%[5]
	
	;Field ambience%
	
	Field TempSoundEmitter%[MaxRoomEmitters]
	Field TempSoundEmitterX#[MaxRoomEmitters],TempSoundEmitterY#[MaxRoomEmitters],TempSoundEmitterZ#[MaxRoomEmitters]
	Field TempSoundEmitterRange#[MaxRoomEmitters]
	
	Field Shape%, Name$
	Field Commonness%
	Field DisableDecals%
	
	Field TempTriggerboxAmount
	Field TempTriggerbox[128]
	Field TempTriggerboxName$[128]
	
	Field UseLightCones%
	Field DisableOverlapCheck% = True
	Field AutoSpawn%
	
	Field MinX#, MinY#, MinZ#
	Field MaxX#, MaxY#, MaxZ#
End Type 	

Function CreateRoomTemplate.RoomTemplates(meshpath$)
	Local rt.RoomTemplates = New RoomTemplates
	
	rt\objPath = "GFX\map\rooms\"+meshpath
	
	rt\id = RoomTempID
	RoomTempID=RoomTempID+1
	
	Return rt
End Function

Function LoadRoomTemplates(file$)
	CatchErrors("Uncaught (LoadRoomTemplates)")
	Local TemporaryString$, i%, drawtimer%
	Local rt.RoomTemplates = Null
	Local StrTemp$ = ""
	
	Local f = OpenFile(file)
	
	While Not Eof(f)
		If drawtimer >= 5 Then
			DrawLoading(-1,True,"","Rooms")
			drawtimer = 0
		Else
			drawtimer = drawtimer + 1
		EndIf	
		TemporaryString = Trim(ReadLine(f))
		If Left(TemporaryString,1) = "[" Then
			TemporaryString = Mid(TemporaryString, 2, Len(TemporaryString) - 2)
			If TemporaryString<>"room ambience" Then
				StrTemp = Lower(TemporaryString)+"\"+GetINIString(file, TemporaryString, "mesh")
				
				rt = CreateRoomTemplate(StrTemp)
				rt\Name = Lower(TemporaryString)
				
				StrTemp = Lower(GetINIString(file, TemporaryString, "shape"))
				Select StrTemp
					Case "room1", "1"
						rt\Shape = ROOM1
					Case "room2", "2"
						rt\Shape = ROOM2
					Case "room2c", "2c"
						rt\Shape = ROOM2C
					Case "room3", "3"
						rt\Shape = ROOM3
					Case "room4", "4"
						rt\Shape = ROOM4
				End Select
				
				For i = 0 To 1
					StrTemp = Lower(GetINIString(file, TemporaryString, "zone"+(i+1)))
					
					Select StrTemp
						Case "lcz"
							rt\zone[i] = LCZ
						Case "hcz"
							rt\zone[i] = HCZ
						Case "ez"
							rt\zone[i] = EZ
						Case "rcz"
							rt\zone[i] = RCZ
						Case "bcz"
							rt\zone[i] = BCZ
					End Select
				Next
				
				rt\Commonness = Max(Min(GetINIInt(file, TemporaryString, "commonness"), 100), 0)
				rt\DisableDecals = GetINIInt(file, TemporaryString, "disabledecals")
				rt\UseLightCones = GetINIInt(file, TemporaryString, "usevolumelighting")
				rt\DisableOverlapCheck = GetINIInt(file, TemporaryString, "disableoverlapcheck")
				rt\AutoSpawn = GetINIInt(file, TemporaryString, "autospawn", 0)
			EndIf
		EndIf
	Wend
	
	i = 1
	Repeat
		If drawtimer >= 5 Then
			DrawLoading(-1,True,"","Rooms_ambience")
			drawtimer = 0
		Else
			drawtimer = drawtimer + 1
		EndIf
		StrTemp = GetINIString(file, "room ambience", "ambience"+i)
		If StrTemp = "" Then Exit
		
		RoomAmbience[i]=LoadSound_Strict(StrTemp)
		i=i+1
	Forever
	
	CloseFile f
	
	CatchErrors("LoadRoomTemplates")
End Function


Function LoadRoomMesh(rt.RoomTemplates)
	
	If FileExtension(rt\objPath)="rmesh" Then ;file is roommesh
		rt\obj = LoadRMesh(rt\objPath, rt)
	Else ;file is b3d
		;If rt\objPath <> "" Then rt\obj = LoadWorld(rt\objPath, rt) Else rt\obj = CreatePivot()
	EndIf
	
	If (Not rt\obj) Then RuntimeError "Failed to load map file "+Chr(34)+rt\objPath+Chr(34)+"."
	
	CalculateRoomTemplateExtents(rt)
	
	HideEntity(rt\obj)
	
End Function

Global RoomScale# = 8.0 / 2048.0
Const ZONEAMOUNT = 3

Const MapWidth% = 18, MapHeight% = 18

Global MapTemp%[(MapWidth + 1) * (MapHeight + 1)]
Global MapFound%[(MapWidth + 1) * (MapHeight + 1)]

Global RoomAmbience%[20]

Global Sky

Global HideDistance# = 15.0

Global SecondaryLightOn# = True
Global PrevSecondaryLightOn# = True
Global RemoteDoorOn = True

Type Rooms
	Field zone%
	Field found%
	Field obj%
	Field x#, y#, z#
	Field angle%
	Field RoomTemplate.RoomTemplates
	
	Field dist#
	
	Field SoundCHN%
	
	Field fr.Forest
	
	Field SoundEmitter%[MaxRoomEmitters]
	Field SoundEmitterObj%[MaxRoomEmitters]
	Field SoundEmitterRange#[MaxRoomEmitters]
	Field SoundEmitterCHN%[MaxRoomEmitters]
	
	Field Lights%[MaxRoomLights]
	Field LightIntensity#[MaxRoomLights]
	
	Field LightSprites%[MaxRoomLights]	
	
	Field Objects%[MaxRoomObjects]
	Field Levers.Lever[11]
	Field RoomDoors.Doors[21]
	Field NPC.NPCs[12]
	Field grid.Grids
	
	Field Adjacent.Rooms[4]
	Field AdjDoor.Doors[4]
	
	Field NonFreeAble%[10]
	Field Textures%[10]
	
	;New Room Variables in SCP:CB 1.3 - ENDSHN
	Field MaxLights% = 0
	Field LightSpriteHidden%[MaxRoomLights]
	Field LightSpritesPivot%[MaxRoomLights]
	Field LightSprites2%[MaxRoomLights]
	Field LightHidden%[MaxRoomLights]
	Field LightFlicker%[MaxRoomLights]
	Field AlarmRotor%[1]
	Field AlarmRotorLight%[1]
	Field TriggerboxAmount
	Field Triggerboxes.Triggerbox[8]
	Field MaxWayPointY#
	Field LightR#[MaxRoomLights],LightG#[MaxRoomLights],LightB#[MaxRoomLights]
	Field LightCone%[MaxRoomLights]
	Field LightConeSpark%[MaxRoomLights]
	Field LightConeSparkTimer#[MaxRoomLights]
	
	Field MinX#, MinY#, MinZ#
	Field MaxX#, MaxY#, MaxZ#
End Type 

Type Triggerbox
	Field obj%
	Field Name$
	Field minX#
	Field minY#
	Field minZ#
	Field maxX#
	Field maxY#
	Field maxZ#
End Type

Const gridsz%=20
Type Grids
	Field grid%[gridsz*gridsz]
	Field angles%[gridsz*gridsz]
	Field Meshes%[7]
	Field Entities%[gridsz*gridsz]
	Field waypoints.WayPoints[gridsz*gridsz]
End Type

Function UpdateGrid(grid.Grids)
	;local variables
	Local tx%,ty%
	For tx% = 0 To gridsz-1
		For ty% = 0 To gridsz-1
			If grid\Entities[tx+(ty*gridsz)]<>0 Then
				If Abs(EntityY(Collider,True)-EntityY(grid\Entities[tx+(ty*gridsz)],True))>4.0 Then Exit
				If Abs(EntityX(Collider,True)-EntityX(grid\Entities[tx+(ty*gridsz)],True))<HideDistance Then
					If Abs(EntityZ(Collider,True)-EntityZ(grid\Entities[tx+(ty*gridsz)],True))<HideDistance Then
						ShowEntity grid\Entities[tx+(ty*gridsz)]
					Else
						HideEntity grid\Entities[tx+(ty*gridsz)]
					EndIf
				Else
					HideEntity grid\Entities[tx+(ty*gridsz)]
				EndIf
			EndIf
		Next
	Next
End Function

Function CreateRoom.Rooms(zone%, roomshape%, x#, y#, z#, name$ = "", angle%=0)
	CatchErrors("Uncaught (CreateRoom)")
	Local r.Rooms = New Rooms
	Local rt.RoomTemplates
	Local fll.FluLight
	
	r\zone = zone
	
	r\x = x : r\y = y : r\z = z
	
	r\angle = angle
	
	If name <> "" Then
		name = Lower(name)
		For rt.RoomTemplates = Each RoomTemplates
			If rt\Name = name Then
				r\RoomTemplate = rt
				
				If rt\obj=0 Then LoadRoomMesh(rt)
				
				r\obj = CopyEntity(rt\obj)
				ScaleEntity(r\obj, RoomScale, RoomScale, RoomScale)
				EntityType(r\obj, HIT_MAP)
				EntityPickMode(r\obj, 2)
				
				PositionEntity(r\obj, x, y, z)
				FillRoom(r)
				
				If r\RoomTemplate\UseLightCones
					AddLightCones(r)
				EndIf
				
				CalculateRoomExtents(r)
				
				RotateEntity(r\obj, 0, angle, 0)
				
				Return r
			EndIf
		Next
	EndIf
	
	;debuglog "Still use old randomroom mechanic!"
	
	Local temp% = 0
	For rt.RoomTemplates = Each RoomTemplates
		
		For i = 0 To 4
			If rt\zone[i]=zone Then 
				If rt\Shape = roomshape Then temp=temp+rt\Commonness : Exit
			EndIf
		Next
		
	Next
	
	Local RandomRoom% = Rand(temp)
	temp = 0
	For rt.RoomTemplates = Each RoomTemplates
		For i = 0 To 4
			If rt\zone[i]=zone And rt\Shape = roomshape Then
				temp=temp+rt\Commonness
				If RandomRoom > temp - rt\Commonness And RandomRoom <= temp Then
					r\RoomTemplate = rt
					
					If rt\obj=0 Then LoadRoomMesh(rt)
					
					r\obj = CopyEntity(rt\obj)
					ScaleEntity(r\obj, RoomScale, RoomScale, RoomScale)
					EntityType(r\obj, HIT_MAP)
					EntityPickMode(r\obj, 2)
					
					PositionEntity(r\obj, x, y, z)
					FillRoom(r)
					
					If r\RoomTemplate\UseLightCones
						AddLightCones(r)
					EndIf
					
					CalculateRoomExtents(r)
					Return r	
				End If
			EndIf
		Next
		
	Next
	
	CatchErrors("CreateRoom")
End Function

; This must be called after the room angle has been finalized!
Function SetupTriggerBoxes(r.Rooms)
	Local sx#, sy#, sz#
	Local pxmin#, pxmax#
	Local pzmin#, pzmax#
	Local t.Triggerbox
	
	For i = 0 To r\TriggerboxAmount-1
		t = r\Triggerboxes[i]
		sx = EntityScaleX(t\obj, 1)
		sy = Max(EntityScaleY(t\obj, 1), 0.001)
		sz = EntityScaleZ(t\obj, 1)
		
		GetMeshExtents(t\obj)
		
		pxmin = Cos(r\angle) * sx*Mesh_MinX - Sin(r\angle) * sz*Mesh_MinZ + r\x
		pzmin = Sin(r\angle) * sx*Mesh_MinX + Cos(r\angle) * sz*Mesh_MinZ + r\z
		
		pxmax = Cos(r\angle) * sx*Mesh_MaxX - Sin(r\angle) * sz*Mesh_MaxZ + r\x
		pzmax = Sin(r\angle) * sx*Mesh_MaxX + Cos(r\angle) * sz*Mesh_MaxZ + r\z
		
		If pxmin > pxmax Then
			t\minX = pxmax
			t\maxX = pxmin
		Else
			t\minX = pxmin
			t\maxX = pxmax
		EndIf
		
		If pzmin > pzmax Then
			t\minZ = pzmax
			t\maxZ = pzmin
		Else
			t\minZ = pzmin
			t\maxZ = pzmax
		EndIf
		
		t\minY = ((sy*Mesh_MinY)+r\y)
		t\maxY = ((sy*Mesh_MaxY)+r\y)
	Next
End Function

;[Block]
Function CheckTriggers$()
	If PlayerRoom\TriggerboxAmount = 0
		Return
	Else
		For i = 0 To PlayerRoom\TriggerboxAmount-1
			If DebugHUD
				EntityAlpha(PlayerRoom\Triggerboxes[i]\obj, 0.2)
			Else
				EntityAlpha(PlayerRoom\Triggerboxes[i]\obj, 0.0)
 			EndIf
			
			If EntityX(Collider)>PlayerRoom\Triggerboxes[i]\minX And EntityX(Collider)<PlayerRoom\Triggerboxes[i]\maxX
				If EntityY(Collider)>PlayerRoom\Triggerboxes[i]\minY And EntityY(Collider)<PlayerRoom\Triggerboxes[i]\maxY
					If EntityZ(Collider)>PlayerRoom\Triggerboxes[i]\minZ And EntityZ(Collider)<PlayerRoom\Triggerboxes[i]\maxZ
						Return PlayerRoom\Triggerboxes[i]\Name
					EndIf
				EndIf
			EndIf
		Next
	EndIf
End Function
;[End Block]

Function UpdateRooms()
	CatchErrors("Uncaught (UpdateRooms)")
	Local i%, j%, r.Rooms
	
	Local x#,z#,hide%=True
	
	;PlayerZone=Min(Max(GetZone(EntityZ(Collider)/8.0),0),ZONEAMOUNT-1)
	
	TempLightVolume=0
	Local foundNewPlayerRoom% = False
	If PlayerRoom<>Null Then
		If Abs(EntityY(Collider) - EntityY(PlayerRoom\obj)) < 1.5 Then
			x = Abs(PlayerRoom\x-EntityX(Collider,True))
			If x < 4.0 Then
				z = Abs(PlayerRoom\z-EntityZ(Collider,True))
				If z < 4.0 Then
					foundNewPlayerRoom = True
				EndIf
			EndIf
			
			If foundNewPlayerRoom = False Then ;it's likely that an adjacent room is the new player room, check for that
				For i=0 To 3
					If PlayerRoom\Adjacent[i]<>Null Then
						x = Abs(PlayerRoom\Adjacent[i]\x-EntityX(Collider,True))
						If x < 4.0 Then
							z = Abs(PlayerRoom\Adjacent[i]\z-EntityZ(Collider,True))
							If z < 4.0 Then
								foundNewPlayerRoom = True
								PlayerRoom = PlayerRoom\Adjacent[i]
								Exit
							EndIf
						EndIf
					EndIf
				Next
			EndIf
		Else
			foundNewPlayerRoom = True ;PlayerRoom stays the same when you're high up, or deep down
		EndIf
	EndIf
	
	For r.Rooms = Each Rooms
		
		x = Abs(r\x-EntityX(Collider,True))
		z = Abs(r\z-EntityZ(Collider,True))
		r\dist = Max(x,z)
		
		If x<16 And z < 16 Then
			For i = 0 To MaxRoomEmitters-1
				If r\SoundEmitter[i]<>0 Then 
					If EntityDistanceSquared(r\SoundEmitterObj[i],Collider) < PowTwo(r\SoundEmitterRange[i]) Then
						r\SoundEmitterCHN[i] = LoopSound2(RoomAmbience[r\SoundEmitter[i]],r\SoundEmitterCHN[i], Camera, r\SoundEmitterObj[i],r\SoundEmitterRange[i])
					EndIf
				EndIf
			Next
			
			If (Not foundNewPlayerRoom) And (PlayerRoom<>r) Then				
				If x < 4.0 Then
					If z < 4.0 Then
						If Abs(EntityY(Collider) - EntityY(r\obj)) < 1.5 Then PlayerRoom = r
						foundNewPlayerRoom = True
					EndIf
				EndIf				
			EndIf
		EndIf
		
		hide = True
		
		If r=PlayerRoom Then hide = False
		If hide Then
			If IsRoomAdjacent(PlayerRoom,r) Then hide = False
		EndIf
		If hide Then
			For i=0 To 3
				If (IsRoomAdjacent(PlayerRoom\Adjacent[i],r)) Then hide=False : Exit
			Next
		EndIf
		
		If hide Then
			EntityAlpha(GetChild(r\obj,2),0)
			HideEntity r\obj
		Else
			ShowEntity r\obj
			EntityAlpha(GetChild(r\obj,2),0)
			For i = 0 To MaxRoomLights-1
				If r\Lights[i] <> 0 Then
					Local dist = EntityDistance(Collider,r\Lights[i])
					If dist < HideDistance Then
						TempLightVolume = TempLightVolume + r\LightIntensity[i]*r\LightIntensity[i]*((HideDistance-dist)/HideDistance)
					EndIf
				Else
					Exit
				EndIf
			Next
		EndIf
	Next
	
	PlayerRoom\found = True
	
	TempLightVolume = Max(TempLightVolume / 4.5, 1.0)
	
	If PlayerRoom<>Null Then
		EntityAlpha(GetChild(PlayerRoom\obj,2),1)
		For i=0 To 3
			If PlayerRoom\Adjacent[i]<>Null Then
				If PlayerRoom\AdjDoor[i]<>Null Then
					x = Abs(EntityX(Collider,True)-EntityX(PlayerRoom\AdjDoor[i]\frameobj,True))
					z = Abs(EntityZ(Collider,True)-EntityZ(PlayerRoom\AdjDoor[i]\frameobj,True))
					If PlayerRoom\AdjDoor[i]\openstate = 0 Then
						EntityAlpha(GetChild(PlayerRoom\Adjacent[i]\obj,2),0)
					ElseIf (Not EntityInView(PlayerRoom\AdjDoor[i]\frameobj,Camera))
						EntityAlpha(GetChild(PlayerRoom\Adjacent[i]\obj,2),0)
					Else
						EntityAlpha(GetChild(PlayerRoom\Adjacent[i]\obj,2),1)
					EndIf
				EndIf
				
				For j=0 To 3
					If (PlayerRoom\Adjacent[i]\Adjacent[j]<>Null) Then
						If (PlayerRoom\Adjacent[i]\Adjacent[j]<>PlayerRoom) Then EntityAlpha(GetChild(PlayerRoom\Adjacent[i]\Adjacent[j]\obj,2),0)
					EndIf
				Next
			EndIf
		Next
	EndIf
	
End Function

Function IsRoomAdjacent(this.Rooms,that.Rooms)
	If this=Null Then Return False
	If this=that Then Return True
	For i=0 To 3
		If that=this\Adjacent[i] Then Return True
	Next
	Return False
End Function

;-------------------------------------------------------------------------------------------------------

Global LightVolume#, TempLightVolume#
Function AddLight%(room.Rooms, x#, y#, z#, ltype%, range#, r%, g%, b%, customent%=0, customflags%=1+8)
	Local i
	
	If room<>Null Then
		For i = 0 To MaxRoomLights-1
			If room\Lights[i]=0 Then
				room\Lights[i] = CreateLight(ltype)
				;room\LightDist[i] = range
				LightRange(room\Lights[i],range)
				LightColor(room\Lights[i],r,g,b)
				PositionEntity(room\Lights[i],x,y,z,True)
				EntityParent(room\Lights[i],room\obj)
				If customent<>0
					EntityParent(room\Lights[i],customent)
				EndIf
				
				room\LightIntensity[i] = (r+g+b)/255.0/3.0
				
				room\LightSprites[i]= CreateSprite()
				PositionEntity(room\LightSprites[i], x, y, z)
				ScaleSprite(room\LightSprites[i], 0.13 , 0.13)
				EntityTexture(room\LightSprites[i], LightSpriteTex[0])
				EntityFX(room\LightSprites[i],customflags%)
				EntityBlend (room\LightSprites[i], 3)
				
				EntityParent(room\LightSprites[i], room\obj)
				If customent<>0
					EntityParent(room\LightSprites[i],customent)
				EndIf
				EntityColor(room\LightSprites[i], r%, g%, b%)
				
				room\LightSpritesPivot[i] = CreatePivot()
				EntityRadius room\LightSpritesPivot[i],0.05
				PositionEntity(room\LightSpritesPivot[i], x, y, z)
				EntityParent(room\LightSpritesPivot[i], room\obj)
				If customent<>0
					EntityParent(room\LightSpritesPivot[i],customent)
				EndIf
				
				room\LightSprites2[i] = CreateSprite()
				PositionEntity(room\LightSprites2[i], x, y, z)
				ScaleSprite(room\LightSprites2[i], 0.6, 0.6)
				EntityTexture(room\LightSprites2[i], LightSpriteTex[2])
				EntityBlend(room\LightSprites2[i], 3)
				EntityOrder(room\LightSprites2[i], -1)
				EntityColor(room\LightSprites2[i], r%, g%, b%)
				EntityParent(room\LightSprites2[i], room\obj)
				If customent<>0
					EntityParent(room\LightSprites2[i],customent)
				EndIf
				EntityFX(room\LightSprites2[i],customflags%)
				RotateEntity(room\LightSprites2[i],0,0,Rand(360))
				SpriteViewMode(room\LightSprites2[i],1)
				room\LightSpriteHidden%[i] = True
				HideEntity room\LightSprites2[i]
				room\LightFlicker%[i] = Rand(1,10)
				
				room\LightR[i] = r
				room\LightG[i] = g
				room\LightB[i] = b
				
				HideEntity room\Lights[i]
				
				room\MaxLights% = room\MaxLights% + 1
				
				Return room\Lights[i]
			EndIf
		Next
	Else
		Local light%,sprite%
		light=CreateLight(ltype)
		LightRange(light,range)
		LightColor(light,r,g,b)
		PositionEntity(light,x,y,z,True)
		If customent<>0
			EntityParent(light,customent)
		EndIf
		sprite=CreateSprite()
		EntityFX sprite,1+8
		PositionEntity(sprite, x, y, z)
		If customent<>0
			EntityParent(sprite,customent)
		EndIf
		ScaleSprite(sprite, 0.13 , 0.13)
		EntityTexture(sprite, LightSpriteTex[0])
		EntityBlend (sprite, 3)
		Return light
	EndIf
End Function

Type LightTemplates
	Field roomtemplate.RoomTemplates
	Field ltype%
	Field x#, y#, z#
	Field range#
	Field r%, g%, b%
	
	Field pitch#, yaw#
	Field innerconeangle%, outerconeangle#
End Type 

Function AddTempLight.LightTemplates(rt.RoomTemplates, x#, y#, z#, ltype%, range#, r%, g%, b%)
	lt.lighttemplates = New LightTemplates
	lt\roomtemplate = rt
	lt\x = x
	lt\y = y
	lt\z = z
	lt\ltype = ltype
	lt\range = range
	lt\r = r
	lt\g = g
	lt\b = b
	
	Return lt
End Function

;-------------------------------------------------------------------------------------------------------

Type TempWayPoints
	Field x#, y#, z#
	Field roomtemplate.RoomTemplates
End Type 

Type WayPoints
	Field obj
	Field door.Doors
	Field room.Rooms
	Field state%
	;Field tempDist#
	;Field tempSteps%
	Field connected.WayPoints[5]
	Field dist#[5]
	
	Field Fcost#, Gcost#, Hcost#
	
	Field parent.WayPoints
End Type

Function CreateWaypoint.WayPoints(x#,y#,z#,door.Doors, room.Rooms)
	Local w.WayPoints = New WayPoints
	
	If 1 Then
		w\obj = CreatePivot()
		PositionEntity w\obj, x,y,z	
	Else
		w\obj = CreateSprite()
		PositionEntity(w\obj, x, y, z)
		ScaleSprite(w\obj, 0.15 , 0.15)
		EntityTexture(w\obj, LightSpriteTex[0])
		EntityBlend (w\obj, 3)	
	EndIf
	
	EntityParent w\obj, room\obj
	
	w\room = room
	w\door=door
	
	Return w
End Function

Function InitWayPoints(loadingstart=45,drawloadingscreen%=True)
	CatchErrors("IntWayPoints()")
	Local d.Doors, w.WayPoints, w2.WayPoints, r.Rooms, ClosestRoom.Rooms
	Local x#, y#, z#
	Local temper%, amount#, number%, iter%
	Local i%, n%
	
	temper = MilliSecs()
	
	Local dist#, dist2#
	
	For d.Doors = Each Doors
		If d\obj <> 0 Then HideEntity d\obj
		If d\obj2 <> 0 Then HideEntity d\obj2	
		If d\frameobj <> 0 Then HideEntity d\frameobj
		
		If d\room = Null Then 
			ClosestRoom.Rooms = Null
			dist# = 30
			For r.Rooms = Each Rooms
				x# = Abs(EntityX(r\obj,True)-EntityX(d\frameobj,True))
				If x < 20.0 Then
					z# = Abs(EntityZ(r\obj,True)-EntityZ(d\frameobj,True))
					If z < 20.0 Then
						dist2 = x*x+z*z
						If dist2 < dist Then
							ClosestRoom = r
							dist = dist2
						EndIf
					EndIf
				EndIf
			Next
		Else
			ClosestRoom = d\room
		EndIf
		
		If (Not d\DisableWaypoint) Then CreateWaypoint(EntityX(d\frameobj, True), EntityY(d\frameobj, True)+0.18, EntityZ(d\frameobj, True), d, ClosestRoom)
	Next
	
	amount# = 0
	For w.WayPoints = Each WayPoints
		EntityPickMode w\obj, 1, True
		EntityRadius w\obj, 0.2
		amount=amount+1
	Next
	
	;pvt = CreatePivot()
	
	number = 0
	iter = 0
	For w.WayPoints = Each WayPoints
		
		number = number + 1
		iter = iter + 1
		If iter = 5 Then ;20
			If drawloadingscreen Then DrawLoading(loadingstart+Floor((35.0/amount)*number),False,"","Waypoints")
			iter = 0
		EndIf
		
		w2.WayPoints = After(w)
		
		Local canCreateWayPoint% = False
		
		While (w2<>Null)
			
			If (w\room=w2\room Lor w\door<>Null Lor w2\door<>Null)
				
				dist# = EntityDistance(w\obj, w2\obj);;Sqr(x*x+y*y+z*z)
				
				If w\room\MaxWayPointY# = 0.0 Lor w2\room\MaxWayPointY# = 0.0
					canCreateWayPoint = True
				Else
					If Abs(EntityY(w\obj)-EntityY(w2\obj))<=w\room\MaxWayPointY
						canCreateWayPoint = True
					EndIf
				EndIf
				
				If dist < 7.0 Then
					If canCreateWayPoint
						If EntityVisible(w\obj, w2\obj) Then;e=w2\obj Then 
							For i = 0 To 4
								If w\connected[i] = Null Then
									w\connected[i] = w2.WayPoints 
									w\dist[i] = dist
									Exit
								EndIf
							Next
							
							For n = 0 To 4
								If w2\connected[n] = Null Then 
									w2\connected[n] = w.WayPoints 
									w2\dist[n] = dist
									Exit
								EndIf					
							Next
						EndIf
					EndIf	
				EndIf
			EndIf
			w2 = After(w2)
		Wend
		
	Next
	
	;pvt = FreeEntity_Strict(pvt)	
	
	For d.Doors = Each Doors
		If d\obj <> 0 Then ShowEntity d\obj
		If d\obj2 <> 0 Then ShowEntity d\obj2	
		If d\frameobj <> 0 Then ShowEntity d\frameobj		
	Next
	
	For w.WayPoints = Each WayPoints
		EntityPickMode w\obj, 0, 0
		EntityRadius w\obj, 0
		
;		For i = 0 To 4
;			If w\connected[i]<>Null Then 
;				tline = CreateLine(EntityX(w\obj,True),EntityY(w\obj,True),EntityZ(w\obj,True),EntityX(w\connected[i]\obj,True),EntityY(w\connected[i]\obj,True),EntityZ(w\connected[i]\obj,True))
;				EntityColor(tline, 255,0,0)
;				EntityParent tline, w\obj
;			EndIf
;		Next
	Next
	
	;debuglog "InitWaypoints() - "+(MilliSecs()-temper)
End Function

Function RemoveWaypoint(w.WayPoints)
	CatchErrors("RemoveWaypoints()")
	
	w\obj = FreeEntity_Strict(w\obj)
	Delete w
End Function

Function FindPath(n.NPCs, x#, y#, z#)
	CatchErrors("FindPath()")
	;debuglog "findpath: "+n\NPCtype
	
	Local temp%, dist#, dist2#
	Local xtemp#, ytemp#, ztemp#
	
	Local i
	
	Local w.WayPoints, StartPoint.WayPoints, EndPoint.WayPoints   
	
	;Local StartX% = Floor(EntityX(n\Collider,True) / 8.0 + 0.5), StartZ% = Floor(EntityZ(n\Collider,True) / 8.0 + 0.5)
	
	;Local EndX% = Floor(x / 8.0 + 0.5), EndZ% = Floor(z / 8.0 + 0.5)
	
	
	;Local CurrX, CurrZ

   ;pathstatus = 0, route hasn't been searched for yet
   ;pathstatus = 1, route found
   ;pathstatus = 2, route not found (target unreachable)
	
	For w.WayPoints = Each WayPoints
		w\state = 0
		w\Fcost = 0
		w\Gcost = 0
		w\Hcost = 0
	Next
	
	n\PathStatus = 0
	n\PathLocation = 0
	For i = 0 To 19
		n\Path[i] = Null
	Next
	
	Local pvt = CreatePivot()
	PositionEntity(pvt, x,y,z, True)   
	
	temp = CreatePivot()
	PositionEntity(temp, EntityX(n\Collider,True), EntityY(n\Collider,True)+0.15, EntityZ(n\Collider,True))
	
	dist = 350.0
	For w.WayPoints = Each WayPoints
;		xtemp = EntityX(w\obj,True)-EntityX(temp,True)
;		ztemp = EntityZ(w\obj,True)-EntityZ(temp,True)
;		ytemp = EntityY(w\obj,True)-EntityY(temp,True)
;		dist2# = (xtemp*xtemp)+(ytemp*ytemp)+(ztemp*ztemp)
		dist2# = EntityDistanceSquared(w\obj,temp)
		If dist2 < dist Then 
			;prefer waypoints that are visible
			If Not EntityVisible(w\obj, temp) Then dist2 = dist2*3
			If dist2 < dist Then 
				dist = dist2
				StartPoint = w
			EndIf
		EndIf
	Next
	;debuglog "DIST: "+dist
	
	temp = FreeEntity_Strict(temp)
	
	If StartPoint = Null Then
		pvt = FreeEntity_Strict(pvt)
		Return 2
	EndIf
	StartPoint\state = 1      
	
	EndPoint = Null
	dist# = 400.0
	For w.WayPoints = Each WayPoints
;		xtemp = Abs(EntityX(pvt,True)-EntityX(w\obj,True))
;		ztemp = Abs(EntityZ(pvt,True)-EntityZ(w\obj,True))
;		ytemp = Abs(EntityY(pvt,True)-EntityY(w\obj,True))
;		dist2# = (xtemp*xtemp)+(ytemp*ytemp)+(ztemp*ztemp)
;		dist2# = xtemp+ztemp+Abs(EntityY(w\obj,True)-EntityY(pvt,True))
		dist2# = EntityDistanceSquared(pvt,w\obj)
		If dist2 < dist Then
			dist = dist2
			EndPoint = w
		EndIf
	Next
	
	pvt = FreeEntity_Strict(pvt)
	
	If EndPoint = StartPoint Then
		If dist < 0.4 Then
			Return 0
		Else
			n\Path[0]=EndPoint
			Return 1               
		EndIf
	EndIf
	If EndPoint = Null Then Return 2
	
	Repeat
		
		temp% = False
		Local smallest.WayPoints = Null
		dist# = 10000.0
		For w.WayPoints = Each WayPoints
			If w\state = 1 Then
                temp = True
                If (w\Fcost) < dist Then
					dist = w\Fcost
					smallest = w
                EndIf
			EndIf
		Next
		
		If smallest <> Null Then
			
			w = smallest
			w\state = 2
			
			For i = 0 To 4
                If w\connected[i]<>Null Then
					If w\connected[i]\state < 2 Then
						
						If w\connected[i]\state=1 Then ;open list
							Local gtemp# = w\Gcost+w\dist[i]
							If n\NPCtype = NPC_NTF Then
								If w\connected[i]\door = Null Then gtemp = gtemp + 0.5
							EndIf
							If gtemp < w\connected[i]\Gcost Then ;parempi reitti -> overwrite
								w\connected[i]\Gcost = gtemp
								w\connected[i]\Fcost = w\connected[i]\Gcost + w\connected[i]\Hcost
								w\connected[i]\parent = w
							EndIf
						Else
							w\connected[i]\Hcost# = Abs(EntityX(w\connected[i]\obj,True)-EntityX(EndPoint\obj,True))+Abs(EntityZ(w\connected[i]\obj,True)-EntityZ(EndPoint\obj,True))
							gtemp# = w\Gcost+w\dist[i]
							If n\NPCtype = NPC_NTF Then
								If w\connected[i]\door = Null Then gtemp = gtemp + 0.5
							EndIf
							w\connected[i]\Gcost = gtemp
							w\connected[i]\Fcost = w\Gcost+w\Hcost
							w\connected[i]\parent = w
							w\connected[i]\state=1
						EndIf            
					EndIf
					
                EndIf
			Next
		Else ;open listilt ei lytynyt mitn
			If EndPoint\state > 0 Then
                StartPoint\parent = Null
                EndPoint\state = 2
                Exit
			EndIf
		EndIf
		
		If EndPoint\state > 0 Then
			StartPoint\parent = Null
			EndPoint\state = 2
			Exit
		EndIf
		
	Until temp = False
	
	If EndPoint\state > 0 Then
		
		Local currpoint.WayPoints = EndPoint
		Local twentiethpoint.WayPoints = EndPoint
		
		Local length = 0
		Repeat
			length = length +1
			currpoint = currpoint\parent
			If length>19 Then ;20
                twentiethpoint = twentiethpoint\parent
			EndIf
		Until currpoint = Null
		
		currpoint.WayPoints = EndPoint
		While twentiethpoint<>Null
			length=Min(length-1,19)
			twentiethpoint = twentiethpoint\parent
			n\Path[length] = twentiethpoint
		Wend
		
		Return 1
	Else
		;debuglog "FUNCTION FindPath() - no route found"
		Return 2 
	EndIf
	
End Function

Function CreateLine(x1#,y1#,z1#, x2#,y2#,z2#, mesh=0)
	
	If mesh = 0 Then 
		mesh=CreateMesh()
		EntityFX(mesh,16)
		Local surf=CreateSurface(mesh)	
		Local verts = 0	
		
		AddVertex surf,x1#,y1#,z1#,0,0
	Else
		surf = GetSurface(mesh,1)
		verts = CountVertices(surf)-1
	End If
	
	AddVertex surf,(x1#+x2#)/2,(y1#+y2#)/2,(z1#+z2#)/2,0,0 
	; you could skip creating the above vertex and change the line below to
	; AddTriangle surf,verts,verts+1,verts+0
	; so your line mesh would use less vertices, the drawback is that some videocards (like the matrox g400)
	; aren't able to create a triangle with 2 vertices. so, it's your call :)
	AddVertex surf,x2#,y2#,z2#,1,0
	
	AddTriangle surf,verts,verts+2,verts+1
	
	Return mesh
End Function

;-------------------------------------------------------------------------------------------------------

Global SelectedScreen.Screens
Type Screens
	Field obj%
	Field imgpath$
	Field img
	Field room.Rooms
End Type

Type TempScreens
	Field imgpath$
	Field x#,y#,z#
	Field roomtemplate.RoomTemplates
End Type

Function CreateScreen.Screens(x#,y#,z#,imgpath$,r.Rooms)
	s.screens = New Screens
	s\obj = CreatePivot()
	EntityPickMode(s\obj, 1)	
	EntityRadius s\obj, 0.1
	
	PositionEntity s\obj, x,y,z
	s\imgpath = imgpath
	s\room = r
	EntityParent s\obj, r\obj
	
	Return s
End Function

Function UpdateScreens()
	CatchErrors("UpdateScreens()")
	Local s.Screens
	
	If SelectedScreen <> Null Then Return
	If d_I\SelectedDoor <> Null Then Return
	
	For s = Each Screens
		If s\room = PlayerRoom Then
			If EntityDistanceSquared(Collider,s\obj)<PowTwo(1.2) Then
				EntityPick(Camera, 1.2)
				If PickedEntity()=s\obj And s\imgpath<>"" Then
					DrawHandIcon=True
					;If MouseUp1 Then
					If KeyHitUse
						SelectedScreen=s
						s\img = LoadImage_Strict("GFX\screens\"+s\imgpath)
						s\img = ResizeImage2(s\img, ImageWidth(s\img) * MenuScale, ImageHeight(s\img) * MenuScale)
						MaskImage s\img, 255,0,255
						PlaySound_Strict ButtonSFX[0]
						MouseUp1=False
					EndIf
				EndIf
			EndIf
		EndIf
	Next
	CatchErrors("UpdateScreens()/uncaught")
End Function

;-------------------------------------------------------------------------------------------------------


Global SelectedMonitor.SecurityCams
Global CoffinCam.SecurityCams
Type SecurityCams
	Field obj%, MonitorObj%, Pvt%
	
	Field BaseObj%, CameraObj%
	
	Field ScrObj%, ScrWidth#, ScrHeight#
	Field Screen%, Cam%, ScrTexture%, ScrOverlay%
	Field angle#, turn#, CurrAngle#
	Field State#, PlayerState%
	
	Field soundCHN%
	
	Field InSight%
	
	Field RenderInterval#
	
	Field room.Rooms
	
	Field FollowPlayer%
	Field CoffinEffect%
	
	Field AllowSaving%
	
	Field MinAngle#, MaxAngle#, dir%
	
	Field IsRoom2slCam% = False
	Field Room2slTexs%[2]
	Field SpecialCam% = False
	Field ID% = -1
	Field Room2slID% = 0
End Type

Global ScreenTexs%[2]

Global CurrRoom2slRenderCam%
Global Room2slCam%

Function CreateSecurityCam.SecurityCams(x#, y#, z#, r.Rooms, screen% = False)
	Local sc.SecurityCams = New SecurityCams
	
	sc\obj = CopyEntity(CamBaseOBJ)
	ScaleEntity(sc\obj, 0.0015, 0.0015, 0.0015)
	sc\CameraObj = CopyEntity(CamOBJ)
	ScaleEntity(sc\CameraObj, 0.01, 0.01, 0.01)
	
	sc\room = r
	
	sc\Screen = screen
	If screen Then
		sc\AllowSaving = True
		
		sc\RenderInterval = 12
		
		Local scale# = RoomScale * 4.5 * 0.4
		
		sc\ScrObj = CreateSprite()
		EntityFX sc\ScrObj, 17
		SpriteViewMode(sc\ScrObj, 2)
		sc\ScrTexture = 0
		EntityTexture sc\ScrObj, ScreenTexs[sc\ScrTexture]
		ScaleSprite(sc\ScrObj, MeshWidth(Monitor) * scale * 0.95 * 0.5, MeshHeight(Monitor) * scale * 0.95 * 0.5)
		
		sc\ScrOverlay = CreateSprite(sc\ScrObj)
		;	scaleSprite(sc\scrOverlay , 0.5, 0.4)
		ScaleSprite(sc\ScrOverlay, MeshWidth(Monitor) * scale * 0.95 * 0.5, MeshHeight(Monitor) * scale * 0.95 * 0.5)
		MoveEntity(sc\ScrOverlay, 0, 0, -0.0005)
		EntityTexture(sc\ScrOverlay, MonitorTexture)
		SpriteViewMode(sc\ScrOverlay, 2)
		EntityBlend(sc\ScrOverlay , 3)
		
		sc\MonitorObj = CopyEntity(Monitor, sc\ScrObj)
		
		ScaleEntity(sc\MonitorObj, scale, scale, scale)
		
		sc\Cam = CreateCamera()
		CameraViewport(sc\Cam, 0, 0, 512, 512)
		CameraRange sc\Cam, 0.05, 6.0
		CameraZoom(sc\Cam, 0.8)
		HideEntity(sc\Cam)	
	End If
	
	PositionEntity(sc\obj, x, y, z)
	
	If r<>Null Then EntityParent(sc\obj, r\obj)
	
	Return sc
End Function

Function UpdateSecurityCams()
	CatchErrors("UpdateSecurityCams")
	
	Local sc.SecurityCams
	
	; ~ CoffinEffect = 0, not affected by SCP-895
	; ~ CoffinEffect = 1, constantly affected by SCP-895
	; ~ CoffinEffect = 2, SCP-079 can broadcast SCP-895 feed on this screen
	; ~ CoffinEffect = 3, SCP-079 broadcasting SCP-895 feed
	
	For sc.SecurityCams = Each SecurityCams
		Local Close% = False
		
		If sc\room = Null Then
			HideEntity(sc\Cam)
		Else
			If sc\room\dist < 6.0 Lor PlayerRoom = sc\room Then 
				Close = True
			ElseIf sc\Cam <> 0
				HideEntity(sc\Cam)
			EndIf
			
			If sc\room <> Null
				If sc\room\RoomTemplate\Name = "room2sl" Then sc\CoffinEffect = 0
			EndIf
			
			If Close Lor sc = CoffinCam Then 
				If sc\FollowPlayer Then
					If sc <> CoffinCam
						If EntityVisible(sc\CameraObj, Camera)
							;If MTFCameraCheckTimer > 0.0 Then MTFCameraCheckDetected = True
							PlayerDetected = True
						EndIf
					EndIf
					If (Not sc\Pvt) Then
						sc\Pvt = CreatePivot(sc\obj)
						EntityParent(sc\Pvt, 0) ;Sets position and rotation of the pivot to the cam object
					EndIf
					PointEntity(sc\Pvt, Camera)
					RotateEntity(sc\CameraObj, CurveAngle(EntityPitch(sc\Pvt), EntityPitch(sc\CameraObj), 75.0), CurveAngle(EntityYaw(sc\Pvt), EntityYaw(sc\CameraObj), 75.0), 0.0)
					PositionEntity(sc\CameraObj, EntityX(sc\obj, True), EntityY(sc\obj, True) - 0.083, EntityZ(sc\obj, True))
				Else
					If sc\turn > 0.0 Then
						If (Not sc\dir) Then
							sc\CurrAngle = sc\CurrAngle + 0.2 * FPSfactor
							If sc\CurrAngle > sc\turn * 1.3 Then sc\dir = True
						Else
							sc\CurrAngle = sc\CurrAngle - 0.2 * FPSfactor
							If sc\CurrAngle < (-sc\turn) * 1.3 Then sc\dir = False
						EndIf
					EndIf
					PositionEntity(sc\CameraObj, EntityX(sc\obj, True), EntityY(sc\obj, True) - 0.083, EntityZ(sc\obj, True))
					RotateEntity(sc\CameraObj, EntityPitch(sc\CameraObj), sc\room\angle + sc\angle + Max(Min(sc\CurrAngle, sc\turn), -sc\turn), 0.0)
					
					;If EntityInView(sc\CameraObj, Camera) And EntityVisible(sc\CameraObj, Camera) Then
					;	If (MilliSecs() Mod 1200) < 800 Then
					;		EntityTexture(sc\CameraObj, t\MiscTextureID[19])
					;	Else
					;		EntityTexture(sc\CameraObj, t\MiscTextureID[18])
					;	EndIf
					;EndIf
					
					If sc\Cam <> 0 Then 
						PositionEntity(sc\Cam, EntityX(sc\CameraObj, True), EntityY(sc\CameraObj, True), EntityZ(sc\CameraObj, True))
						RotateEntity(sc\Cam, EntityPitch(sc\CameraObj), EntityYaw(sc\CameraObj), 0.0)
						MoveEntity(sc\Cam, 0.0, 0.0, 0.1)
					EndIf
					
					If sc <> CoffinCam Then
						If Abs(DeltaYaw(sc\CameraObj, Camera)) < 60.0
							If EntityVisible(sc\CameraObj, Camera)
								;If MTFCameraCheckTimer > 0.0 Then MTFCameraCheckDetected = True
								PlayerDetected = True
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
			
			If Close Then
				If sc\Screen Then
					If sc\State < sc\RenderInterval Then
						sc\State = sc\State + FPSfactor
					Else
						sc\State = 0.0
					EndIf
					
					If BlinkTimer > -5.0 And EntityInView(sc\ScrObj, Camera) Then
						If EntityVisible(Camera, sc\ScrObj) Then
							;If (sc\CoffinEffect = 1 Lor sc\CoffinEffect = 3) And (Not I_714\Using) And wbl\Hazmat <> 3 And wbl\GasMask <> 3 Then
								If BlinkTimer > -5.0 Then
									Sanity = Sanity - FPSfactor
									RestoreSanity = False
								EndIf
							;EndIf
						EndIf
					EndIf
					
					If Sanity < -1000.0 Then 
						m_msg\DeathTxt = Chr(34) + "What we know is that he died of cardiac arrest. My guess is that it was caused by SCP-895, although it has never been observed affecting video equipment from this far before. "
						m_msg\DeathTxt = m_msg\DeathTxt + "Further testing is needed to determine whether SCP-895's " + Chr(34) + "Red Zone" + Chr(34) + " is increasing." + Chr(34)
						
						If VomitTimer < -10.0 Then Kill()
					EndIf
					
					If VomitTimer < 0.0 And Sanity < -800.0 Then
						RestoreSanity = False
						Sanity = -1010.0
					EndIf
					
					If BlinkTimer > -5.0 And EntityInView(sc\ScrObj, Camera) And EntityVisible(Camera, sc\ScrObj) Then
						sc\InSight = True
					Else
						sc\InSight = False
					EndIf
					
					If (sc\CoffinEffect = 1 Lor sc\CoffinEffect = 3) ;And (Not I_714\Using) And wbl\Hazmat <> 3 And wbl\GasMask <> 3 Then
						If sc\InSight Then
							Local Pvt% = CreatePivot()
							
							PositionEntity(Pvt, EntityX(Camera), EntityY(Camera), EntityZ(Camera))
							PointEntity(Pvt, sc\ScrObj)
							
							RotateEntity(Collider, EntityPitch(Collider), CurveAngle(EntityYaw(Pvt), EntityYaw(Collider), Min(Max(15000.0 / (-Sanity), 20.0), 200.0)), 0.0)
							
							TurnEntity(Pvt, 90.0, 0.0, 0.0)
							user_camera_pitch = CurveAngle(EntityPitch(Pvt), user_camera_pitch + 90.0, Min(Max(15000.0 / (-Sanity), 20.0), 200.0))
							user_camera_pitch = user_camera_pitch - 90.0
							
							Pvt = FreeEntity_Strict(Pvt)
						EndIf
					Else
						If sc\InSight Then
							;If I_714\Using Lor wbl\Hazmat = 3 Lor wbl\GasMask = 3 Then EntityTexture(sc\ScrOverlay, MonitorTexture)
						EndIf
					EndIf
					
					If sc\InSight And sc\CoffinEffect = 0 Lor sc\CoffinEffect = 2 Then
						If sc\PlayerState = 0 Then
							sc\PlayerState = Rand(60000, 65000)
						EndIf
						
						;If Rand(500) = 1 Then EntityTexture(sc\ScrOverlay, OldAiPics[0])
						
						If (MilliSecs() Mod sc\PlayerState) >= Rand(600) Then
							EntityTexture(sc\ScrOverlay, MonitorTexture)
						Else
							If (Not sc\soundCHN) Then
								sc\soundCHN = PlaySound_Strict(LoadTempSound("SFX\SCP\079\Broadcast" + Rand(1, 3) + ".ogg"))
								If sc\CoffinEffect = 2 Then sc\CoffinEffect = 3 : sc\PlayerState = 0
							ElseIf (Not ChannelPlaying(sc\soundCHN))
								sc\soundCHN = PlaySound_Strict(LoadTempSound("SFX\SCP\079\Broadcast" + Rand(1, 3) + ".ogg"))
								If sc\CoffinEffect = 2 Then sc\CoffinEffect = 3 : sc\PlayerState = 0
							EndIf
							;EntityTexture(sc\ScrOverlay, OldAiPics[0])
						EndIf
					EndIf
				EndIf
				If (Not sc\InSight) Then sc\soundCHN = LoopSound2(CameraSFX, sc\soundCHN, Camera, sc\CameraObj, 4.0)
			EndIf
		EndIf
	Next
	
	CatchErrors("Uncaught (UpdateSecurityCameras)")
End Function

Function RenderSecurityCams()
	CatchErrors("RenderSecurityCams")
	
	Local sc.SecurityCams
	
	For sc.SecurityCams = Each SecurityCams
		Local Close% = False
		
		If sc\room <> Null Then
			If sc\room\dist < 6.0 Lor PlayerRoom = sc\room Then 
				Close = True
			EndIf
			
			If Close Then
				If sc\Screen Then
					If sc\State >= sc\RenderInterval Then
						If BlinkTimer > -5.0 And EntityInView(sc\ScrObj, Camera) Then
							If EntityVisible(Camera, sc\ScrObj) Then
								If CoffinCam = Null Lor Rand(5) = 5 Lor sc\CoffinEffect <> 3 Then
									HideEntity(Camera)
									ShowEntity(sc\Cam)
									Cls()
									
									;RenderRoomLights(sc\Cam)
									UpdateRoomLights(sc\Cam)
									
									SetBuffer(BackBuffer())
									RenderWorld()
									CopyRect(0, 0, 512, 512, 0, 0, BackBuffer(), TextureBuffer(ScreenTexs[sc\ScrTexture]))
									
									HideEntity(sc\Cam)
									ShowEntity(Camera)										
								Else
									HideEntity(Camera)
									ShowEntity(CoffinCam\room\obj)
									EntityAlpha(GetChild(CoffinCam\room\obj, 2), 1.0)
									ShowEntity(CoffinCam\Cam)
									Cls()
									
									;RenderRoomLights(CoffinCam\Cam)
									UpdateRoomLights(CoffinCam\Cam)
									
									SetBuffer(BackBuffer())
									RenderWorld()
									CopyRect(0, 0, 512, 512, 0, 0, BackBuffer(), TextureBuffer(ScreenTexs[sc\ScrTexture]))
									
									HideEntity(CoffinCam\room\obj)
									HideEntity(CoffinCam\Cam)
									ShowEntity(Camera)										
								EndIf
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	Next
	Cls()
	
	CatchErrors("Uncaught (RenderSecurityCameras)")
End Function

Type Lever
	Field obj%, objBase%
End Type

Function CreateLever.Lever(r.Rooms,x#,y#,z#,rotation%=0,TurnedOn%=False)
	Local lv.Lever = New Lever
	lv\objBase = CopyEntity(LeverBaseOBJ)
	lv\obj = CopyEntity(LeverOBJ)
	
	ScaleEntity(lv\objBase, 0.04, 0.04, 0.04)
	ScaleEntity(lv\obj, 0.04, 0.04, 0.04)
	PositionEntity (lv\objBase, x, y, z, True)
	PositionEntity (lv\obj, x, y, z, True)
	
	EntityParent(lv\objBase, r\obj)
	EntityParent(lv\obj, r\obj)
	
	RotateEntity(lv\objBase, 0, rotation, 0)
	RotateEntity(lv\obj, -80+(160*TurnedOn), rotation-180, 0)
	
	EntityPickMode lv\obj, 1, False
	EntityRadius lv\obj, 0.1
	
	Return lv
End Function

Const LEVER_AXIS_PITCH = 0
Const LEVER_AXIS_YAW = 1
Const LEVER_AXIS_ROLL = 2

Function UpdateLever(obj, locked=False, axis%=LEVER_AXIS_PITCH, lever_min%=-80, lever_max%=80)
	Local prevvalue#, refvalue#
	
	Local dist# = EntityDistanceSquared(Camera, obj)
	If dist < 4.0 Then 
		If dist <= 0.65 And (Not locked) Then 
			If EntityVisible(obj, Camera) Then 
				
				EntityPick(Camera, 0.65)
				
				If PickedEntity() = obj Then
					DrawHandIcon = True
					If KeyHitUse Then
						GrabbedEntity = obj
					EndIf
				EndIf
				
				Select axis
					Case LEVER_AXIS_PITCH
						prevvalue# = EntityPitch(obj)
					Case LEVER_AXIS_YAW
						prevvalue# = EntityYaw(obj)
					Case LEVER_AXIS_ROLL
						prevvalue# = EntityRoll(obj)
				End Select
				
				If (keydownuse Lor keyhituse) Then
					If GrabbedEntity <> 0 Then
						If GrabbedEntity = obj Then
							DrawHandIcon = True
							Select axis
								Case LEVER_AXIS_PITCH
									RotateEntity(GrabbedEntity, Max(Min(EntityPitch(obj)+Max(Min(mouse_y_speed_1 * 8,30.0),-30), lever_max), lever_min), EntityYaw(obj), 0)
								Case LEVER_AXIS_YAW
									RotateEntity(GrabbedEntity, EntityPitch(obj), Max(Min(EntityYaw(obj)+Max(Min(mouse_y_speed_1 * 8,30.0),-30), lever_max), lever_min), 0)
								Case LEVER_AXIS_ROLL
									RotateEntity(GrabbedEntity, EntityPitch(obj), EntityYaw(obj), Max(Min(EntityRoll(obj)+Max(Min(mouse_y_speed_1 * 8,30.0),-30), lever_max), lever_min))
							End Select
							DrawArrowIcon[0] = True
							DrawArrowIcon[2] = True
						EndIf
					EndIf
				EndIf 
				
				Select axis
					Case LEVER_AXIS_PITCH
						refvalue = EntityPitch(obj, True)
					Case LEVER_AXIS_YAW
						refvalue = EntityYaw(obj, True)
					Case LEVER_AXIS_ROLL
						refvalue = EntityRoll(obj, True)
				End Select
				If refvalue > (lever_max-5) Then
					If prevvalue =< (lever_max-5) Then PlaySound2(LeverSFX, Camera, obj, 1.0)
				ElseIf refvalue < (lever_min+5) Then
					If prevvalue => (lever_min+5) Then PlaySound2(LeverSFX, Camera, obj, 1.0)	
				EndIf
			EndIf
		EndIf
		If (KeyDownUse=False And KeyHitUse=False) Then
			GrabbedEntity = 0
		EndIf	
		If GrabbedEntity = 0 Lor dist > 0.65 Then
			Select axis
				Case LEVER_AXIS_PITCH
					If EntityPitch(obj,True) > ((lever_max + lever_min) / 2.0) Then
						RotateEntity(obj, CurveValue(lever_max, EntityPitch(obj), 10), EntityYaw(obj), 0)
					Else
						RotateEntity(obj, CurveValue(lever_min, EntityPitch(obj), 10), EntityYaw(obj), 0)
					EndIf
				Case LEVER_AXIS_YAW
					If EntityYaw(obj,True) > ((lever_max + lever_min) / 2.0) Then
						RotateEntity(obj, EntityPitch(obj), CurveValue(lever_max, EntityYaw(obj), 10), 0)
					Else
						RotateEntity(obj, EntityPitch(obj), CurveValue(lever_min, EntityYaw(obj), 10), 0)
					EndIf
				Case LEVER_AXIS_ROLL
					If EntityRoll(obj,True) > ((lever_max + lever_min) / 2.0) Then
						RotateEntity(obj, EntityPitch(obj), EntityYaw(obj), CurveValue(lever_max, EntityRoll(obj), 10))
					Else
						RotateEntity(obj, EntityPitch(obj), EntityYaw(obj), CurveValue(lever_min, EntityRoll(obj), 10))
					EndIf
			End Select
		EndIf
	EndIf
	
	Select axis
		Case LEVER_AXIS_PITCH
			refvalue = EntityPitch(obj, True)
		Case LEVER_AXIS_YAW
			refvalue = EntityYaw(obj, True)
		Case LEVER_AXIS_ROLL
			refvalue = EntityRoll(obj, True)
	End Select
	If refvalue > ((lever_max + lever_min) / 2.0) Then
		Return True
	Else
		Return False
	EndIf	
	
End Function

Function CreateButton(x#,y#,z#,pitch#,yaw#,roll#=0,model=BUTTON_NORMAL)
	
	Local obj = CopyEntity(d_I\ButtonOBJ[model])
	
	ScaleEntity(obj, 0.03, 0.03, 0.03)
	
	PositionEntity obj, x,y,z
	RotateEntity obj, pitch,yaw,roll
	
	EntityPickMode(obj, 2)
	
	Return obj
End Function

Function UpdateButton(obj)
	Local dist# = EntityDistanceSquared(Collider, obj)
	
	If dist < PowTwo(0.8) Then
		Local temp% = CreatePivot()
		PositionEntity temp, EntityX(Camera), EntityY(Camera), EntityZ(Camera)
		PointEntity temp,obj
		
		If EntityPick(temp, 0.65) = obj Then
			If d_I\ClosestButton = 0 Then 
				d_I\ClosestButton = obj
			Else
				If dist < EntityDistanceSquared(Collider, d_I\ClosestButton) Then d_I\ClosestButton = obj
			EndIf							
		EndIf
		
		temp = FreeEntity_Strict(temp)
	EndIf			
	
End Function

Function UpdateElevators#(State#, door1.Doors, door2.Doors, room1, room2, event.Events, ignorerotation% = True)
	Local x#, z#, sound%
	Local dist#, dir#, n.NPCs, it.Items
	
	door1\IsElevatorDoor = 1
	door2\IsElevatorDoor = 1
	If door1\open = True And door2\open = False And door1\openstate = 180 Then 
		State = -1
		door1\locked = False
		If (d_I\ClosestButton = door2\buttons[0] Lor d_I\ClosestButton = door2\buttons[1]) And KeyHitUse Then
			UseDoor(door1,False)
		EndIf
	ElseIf door2\open = True And door1\open = False And door2\openstate = 180 Then
		State = 1
		door2\locked = False
		If (d_I\ClosestButton = door1\buttons[0] Lor d_I\ClosestButton = door1\buttons[1]) And KeyHitUse Then
			UseDoor(door2,False)
		EndIf
	ElseIf Abs(door1\openstate-door2\openstate)<0.2 Then
		door1\IsElevatorDoor = 2
		door2\IsElevatorDoor = 2
	EndIf
	
	door1\locked = True
	door2\locked = True
	If door1\open Then
		door1\IsElevatorDoor = 3
		If Abs(EntityX(Collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
			If Abs(EntityZ(Collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then	
				If Abs(EntityY(Collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then	
					door1\locked = False
					door1\IsElevatorDoor = 1
				EndIf
			EndIf
		EndIf
	EndIf
	If door2\open Then
		door2\IsElevatorDoor = 3
		If Abs(EntityX(Collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
			If Abs(EntityZ(Collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then	
				If Abs(EntityY(Collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
					door2\locked = False
					door2\IsElevatorDoor = 1
				EndIf
			EndIf
		EndIf	
	EndIf
	
	Local inside = False
	
	If door1\open = False And door2\open = False Then
		door1\locked = True
		door2\locked = True
		If door1\openstate = 0 And door2\openstate = 0 Then
			If State < 0 Then
				State = State - FPSfactor
				If Abs(EntityX(Collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
					If Abs(EntityZ(Collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then	
						If Abs(EntityY(Collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then	
							inside = True
							
							If event\SoundCHN[0] = 0 Then
								event\SoundCHN[0] = PlaySound_Strict(ElevatorMoveSFX)
							Else
								If (Not ChannelPlaying(event\SoundCHN[0])) Then event\SoundCHN[0] = PlaySound_Strict(ElevatorMoveSFX)
							EndIf
							
							CameraShake = Sin(Abs(State)/3.0)*0.3
						EndIf
					EndIf
				EndIf
				
				If State < -500 Then
					door1\locked = True
					door2\locked = False
					State = 0
					
					If inside Then
						If (Not ignorerotation) Then
							dist# = Distance(EntityX(Collider,True),EntityX(room1,True),EntityZ(Collider,True),EntityZ(room1,True))
							dir# = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(room1,True),EntityZ(room1,True))
							dir=dir+EntityYaw(room2,True)-EntityYaw(room1,True)
							dir=WrapAngle(dir)
							x# = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							z# = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							RotateEntity Collider,EntityPitch(Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(Collider,True),EntityYaw(room1,True)),EntityRoll(Collider,True),True
						Else
							x# = Max(Min((EntityX(Collider)-EntityX(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
							z# = Max(Min((EntityZ(Collider)-EntityZ(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
						EndIf
						
						TeleportEntity(Collider, EntityX(room2,True)+x,(0.1*FPSfactor)+EntityY(room2,True)+(EntityY(Collider)-EntityY(room1,True)),EntityZ(room2,True)+z,0.3,True)
						d_I\UpdateDoorsTimer = 0
						DropSpeed = 0
						UpdateDoors()
						UpdateRooms()
						
						sound=Rand(0, 2)
						door2\SoundCHN = PlaySound_Strict(OpenDoorSFX[3 * 3 + sound])
					EndIf
					
					For n.NPCs = Each NPCs
						If Abs(EntityX(n\Collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
							If Abs(EntityZ(n\Collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
								If Abs(EntityY(n\Collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
									If (Not ignorerotation) Then
										dist# = Distance(EntityX(n\Collider,True),EntityX(room1,True),EntityZ(n\Collider,True),EntityZ(room1,True))
										dir# = point_direction(EntityX(n\Collider,True),EntityZ(n\Collider,True),EntityX(room1,True),EntityZ(room1,True))
										dir=dir+EntityYaw(room2,True)-EntityYaw(room1,True)
										dir=WrapAngle(dir)
										x# = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity n\Collider,EntityPitch(n\Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(n\Collider,True),EntityYaw(room1,True)),EntityRoll(n\Collider,True),True
									Else
										x# = Max(Min((EntityX(n\Collider)-EntityX(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min((EntityZ(n\Collider)-EntityZ(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									EndIf
									
									TeleportEntity(n\Collider, EntityX(room2,True)+x,(0.1*FPSfactor)+EntityY(room2,True)+(EntityY(n\Collider)-EntityY(room1,True)),EntityZ(room2,True)+z,n\CollRadius,True)
									If n = Curr173 Then
										Curr173\IdleTimer = 10
									EndIf
								EndIf
							EndIf
						EndIf
					Next
					For it.Items = Each Items
						If Abs(EntityX(it\collider)-EntityX(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
							If Abs(EntityZ(it\collider)-EntityZ(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
								If Abs(EntityY(it\collider)-EntityY(room1,True))<280.0*RoomScale+(0.015*FPSfactor) Then
									If (Not ignorerotation) Then
										dist# = Distance(EntityX(it\collider,True),EntityX(room1,True),EntityZ(it\collider,True),EntityZ(room1,True))
										dir# = point_direction(EntityX(it\collider,True),EntityZ(it\collider,True),EntityX(room1,True),EntityZ(room1,True))
										dir=dir+EntityYaw(room2,True)-EntityYaw(room1,True)
										dir=WrapAngle(dir)
										x# = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity it\collider,EntityPitch(it\collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(it\collider,True),EntityYaw(room1,True)),EntityRoll(it\collider,True),True
									Else
										x# = Max(Min((EntityX(it\collider)-EntityX(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min((EntityZ(it\collider)-EntityZ(room1,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									EndIf
									
									TeleportEntity(it\collider, EntityX(room2,True)+x,(0.1*FPSfactor)+EntityY(room2,True)+(EntityY(it\collider)-EntityY(room1,True)),EntityZ(room2,True)+z,0.01,True)
								EndIf
							EndIf
						EndIf
					Next
					
					UseDoor(door2,False,Not inside)
					door1\open = False
					
					PlaySound2(ElevatorBeepSFX, Camera, room1, 4.0)
				EndIf
			Else
				State = State + FPSfactor
				If Abs(EntityX(Collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
					If Abs(EntityZ(Collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then	
						If Abs(EntityY(Collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
							inside = True
							
							If event\SoundCHN[0] = 0 Then
								event\SoundCHN[0] = PlaySound_Strict(ElevatorMoveSFX)
							Else
								If (Not ChannelPlaying(event\SoundCHN[0])) Then event\SoundCHN[0] = PlaySound_Strict(ElevatorMoveSFX)
							EndIf
							
							CameraShake = Sin(Abs(State)/3.0)*0.3
						EndIf
					EndIf
				EndIf	
				
				If State > 500 Then 
					door1\locked = False
					door2\locked = True				
					State = 0
					
					If inside Then	
						If (Not ignorerotation) Then
							dist# = Distance(EntityX(Collider,True),EntityX(room2,True),EntityZ(Collider,True),EntityZ(room2,True))
							dir# = point_direction(EntityX(Collider,True),EntityZ(Collider,True),EntityX(room2,True),EntityZ(room2,True))
							dir=dir+EntityYaw(room1,True)-EntityYaw(room2,True)
							x# = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							z# = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
							RotateEntity Collider,EntityPitch(Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(Collider,True),EntityYaw(room1,True)),EntityRoll(Collider,True),True
						Else
							x# = Max(Min((EntityX(Collider)-EntityX(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
							z# = Max(Min((EntityZ(Collider)-EntityZ(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
						EndIf
						
						TeleportEntity(Collider, EntityX(room1,True)+x,(0.1*FPSfactor)+EntityY(room1,True)+(EntityY(Collider)-EntityY(room2,True)),EntityZ(room1,True)+z,0.3,True)
						d_I\UpdateDoorsTimer = 0
						DropSpeed = 0
						UpdateDoors()
						UpdateRooms()
						
						sound=Rand(0, 2)
						door1\SoundCHN = PlaySound_Strict(OpenDoorSFX[3 * 3 + sound])
					EndIf
					
					For n.NPCs = Each NPCs
						If Abs(EntityX(n\Collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
							If Abs(EntityZ(n\Collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
								If Abs(EntityY(n\Collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
									If (Not ignorerotation) Then
										dist# = Distance(EntityX(n\Collider,True),EntityX(room2,True),EntityZ(n\Collider,True),EntityZ(room2,True))
										dir# = point_direction(EntityX(n\Collider,True),EntityZ(n\Collider,True),EntityX(room2,True),EntityZ(room2,True))
										dir=dir+EntityYaw(room1,True)-EntityYaw(room2,True)
										x# = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity n\Collider,EntityPitch(n\Collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(n\Collider,True),EntityYaw(room1,True)),EntityRoll(n\Collider,True),True
									Else
										x# = Max(Min((EntityX(n\Collider)-EntityX(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min((EntityZ(n\Collider)-EntityZ(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									EndIf
									
									TeleportEntity(n\Collider, EntityX(room1,True)+x,(0.1*FPSfactor)+EntityY(room1,True)+(EntityY(n\Collider)-EntityY(room2,True)),EntityZ(room1,True)+z,n\CollRadius,True)
									If n = Curr173 Then
										Curr173\IdleTimer = 10
									EndIf
								EndIf
							EndIf
						EndIf
					Next
					For it.Items = Each Items
						If Abs(EntityX(it\collider)-EntityX(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
							If Abs(EntityZ(it\collider)-EntityZ(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
								If Abs(EntityY(it\collider)-EntityY(room2,True))<280.0*RoomScale+(0.015*FPSfactor) Then
									If (Not ignorerotation) Then
										dist# = Distance(EntityX(it\collider,True),EntityX(room2,True),EntityZ(it\collider,True),EntityZ(room2,True))
										dir# = point_direction(EntityX(it\collider,True),EntityZ(it\collider,True),EntityX(room2,True),EntityZ(room2,True))
										dir=dir+EntityYaw(room1,True)-EntityYaw(room2,True)
										x# = Max(Min(Cos(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min(Sin(dir)*dist,280*RoomScale-0.22),-280*RoomScale+0.22)
										RotateEntity it\collider,EntityPitch(it\collider,True),EntityYaw(room2,True)+angleDist(EntityYaw(it\collider,True),EntityYaw(room1,True)),EntityRoll(it\collider,True),True
									Else
										x# = Max(Min((EntityX(it\collider)-EntityX(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
										z# = Max(Min((EntityZ(it\collider)-EntityZ(room2,True)),280*RoomScale-0.22),-280*RoomScale+0.22)
									EndIf
									
									TeleportEntity(it\collider, EntityX(room1,True)+x,(0.1*FPSfactor)+EntityY(room1,True)+(EntityY(it\collider)-EntityY(room2,True)),EntityZ(room1,True)+z,0.01,True)
								EndIf
							EndIf
						EndIf
					Next
					
					UseDoor(door1,False,Not inside)
					door2\open = False
					
					PlaySound2(ElevatorBeepSFX, Camera, room2, 4.0)
				EndIf	
				
			EndIf
		EndIf
	EndIf
	
	Return State
	
End Function
;-------------------------------------------------------------------------------------------------------

Type Props
	Field file$
	Field obj
End Type

Function CreatePropObj(file$)
	Local p.Props
	For p.Props = Each Props
		If p\file = file Then
			Return CopyEntity(p\obj)
		EndIf
	Next
	
	p.Props = New Props
	p\file = file
	p\obj = LoadMesh_Strict(file)
	Return p\obj
End Function

;-------------------------------------------------------------------------------------------------------

Type MapGrid
	Field Grid%[MapGridSize^2]
	Field RoomName$[MapGridSize^2]
	Field RoomAngle%[MapGridSize^2]
	Field RoomType%[MapGridSize^2]
End Type

Global CurrGrid.MapGrid

Function CreateMap()
	;debuglog ("Generating a map using the seed "+RandomSeed)
	CatchErrors("CreateMap(), Map seed:"+RandomSeed)
	Local x%,y%,i,n
	Local startX%,endX%
	Local dir%,success%
	Local adj_amount%,adj_amount2%
	Local iterator_check%
	
	;Variables to determine how the grid should spawn
	Local loopamount%,dimensions%,hallwaychance%
	
	;Set the SeedRnd according to the RandomSeed
	SeedRnd GenerateSeedNumber(RandomSeed)
	
	;Initialize the new Grid (deleting the old one if existing and creating a new one)
	If CurrGrid <> Null Then
		Delete CurrGrid : CurrGrid = Null
	EndIf
	CurrGrid = New MapGrid
	
	CatchErrors("CreateMap(), Stage 0, Map seed:"+RandomSeed)
	If gopt\CurrZone > GATE_A_INTRO And gopt\CurrZone < REACTOR_AREA Then
		;Set a starting position
		startX = Rand(0,MapGridSize-1)
		CurrGrid\Grid[startX] = MapGrid_StartTile
		
		;Set the variables that determin the overall generation
		loopamount = 100
		dimensions = 3
		hallwaychance = 5
		
		;Generate the entire grid
		i = 1
		y = 1
		x = startX
		CurrGrid\Grid[x+MapGridSize] = MapGrid_Tile
		CatchErrors("CreateMap(), Stage 1, Map seed:"+RandomSeed)
		Repeat
			dir = Rand(0,3)
			If (dir Mod 2)=0 Then
				If Rand(1,hallwaychance)<hallwaychance Then
					dir = dir + 1
				EndIf
			EndIf
			dir = (dir Mod 4)
			success = False
			Select dir
				Case 0 ;down
					If y < MapGridSize-(dimensions+1) Then
						y = y + dimensions
						For n = 1 To dimensions-1
							CurrGrid\Grid[x+((y-n)*MapGridSize)] = MapGrid_Tile
						Next
						success = True
					EndIf
				Case 1 ;left
					If x >= dimensions Then
						x = x - dimensions
						For n = 1 To dimensions-1
							CurrGrid\Grid[(x+n)+(y*MapGridSize)] = MapGrid_Tile
						Next
						success = True
					EndIf
				Case 2 ;up
					If y > dimensions Then
						y = y - dimensions
						For n = 1 To dimensions-1
							CurrGrid\Grid[x+((y+n)*MapGridSize)] = MapGrid_Tile
						Next
						success = True
					EndIf
				Case 3 ;right
					If x <= MapGridSize-(dimensions+1) Then
						x = x + dimensions
						For n = 1 To dimensions-1
							CurrGrid\Grid[(x-n)+(y*MapGridSize)] = MapGrid_Tile
						Next
						success = True
					EndIf
			End Select
			If success Then
				CurrGrid\Grid[x+(y*MapGridSize)] = MapGrid_Tile
				i = i + 1
			EndIf
		Until ((i >= loopamount) And (y>=MapGridSize-2))
		
		;debuglog "Map Generator Stage 1 complete"
		
		;Add the end position
		endX = x
		CurrGrid\Grid[endX+((MapGridSize-1)*MapGridSize)] = MapGrid_EndTile
		
		;Force more rooms to spawn (10 to 20 more)
		i = 0
		iterator_check = 0
		CatchErrors("CreateMap(), Stage 2, Map seed:"+RandomSeed)
		Repeat
			For x = 1 To MapGridSize-2
				For y = 1 To MapGridSize-2
					If CurrGrid\Grid[x+(y*MapGridSize)]=MapGrid_NoTile And Rand(1,15)=1 Then
						adj_amount = 0
						If CurrGrid\Grid[x+((y+1)*MapGridSize)]>MapGrid_NoTile Then
							adj_amount = adj_amount + 1
						EndIf
						If CurrGrid\Grid[x+((y-1)*MapGridSize)]>MapGrid_NoTile Then
							adj_amount = adj_amount + 1
						EndIf
						If CurrGrid\Grid[(x+1)+(y*MapGridSize)]>MapGrid_NoTile Then
							adj_amount = adj_amount + 1
						EndIf
						If CurrGrid\Grid[(x-1)+(y*MapGridSize)]>MapGrid_NoTile Then
							adj_amount = adj_amount + 1
						EndIf
						If adj_amount = 1 Then
							CurrGrid\Grid[x+(y*MapGridSize)]=MapGrid_Tile
							i = i + Rand(1,2)
							iterator_check = 0
						EndIf
					EndIf
				Next
			Next
			iterator_check = iterator_check + 1
		Until (i >= 20) Lor (iterator_check >= 20)
		
		;debuglog "Map Generator Stage 2 complete"
		
		;Assign the room types and rotation for each room
		CatchErrors("CreateMap(), Stage 3, Map seed:"+RandomSeed)
		Local temp = 0
		For y = 1 To MapGridSize-2
			For x = 0 To MapGridSize-1
				If CurrGrid\Grid[x+(y*MapGridSize)] > 0 Then
					temp = 0
					If x < MapGridSize-1 Then
						temp=Min(CurrGrid\Grid[(x+1)+(y*MapGridSize)],1)
					EndIf
					If x > 0 Then
						temp=temp+Min(CurrGrid\Grid[(x-1)+(y*MapGridSize)],1)
					EndIf
					temp=temp+Min(CurrGrid\Grid[x+((y+1)*MapGridSize)],1)+Min(CurrGrid\Grid[x+((y-1)*MapGridSize)],1)
					
					;debuglog temp
					
					Select temp
						Case 1
							If CurrGrid\Grid[x+((y+1)*MapGridSize)]>0 Then
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 2
							ElseIf CurrGrid\Grid[(x-1)+(y*MapGridSize)]>0 And (x>=0) Then
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 3
							ElseIf CurrGrid\Grid[(x+1)+(y*MapGridSize)]>0 And (x<MapGridSize-1) Then
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 1
							Else
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 0
							EndIf
							CurrGrid\RoomType[x+(y*MapGridSize)] = ROOM1
						Case 2
							If CurrGrid\Grid[(x-1)+(y*MapGridSize)]>0 And CurrGrid\Grid[(x+1)+(y*MapGridSize)]>0 And (x>=0) And (x<MapGridSize-1) Then
								If Rand(2) = 1 Then
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 1
								Else
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 3
								EndIf
								CurrGrid\RoomType[x+(y*MapGridSize)] = ROOM2
							ElseIf CurrGrid\Grid[x+((y-1)*MapGridSize)]>0 And CurrGrid\Grid[x+((y+1)*MapGridSize)]>0 Then
								If Rand(2) = 1 Then
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 2
								Else
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 0
								EndIf
								CurrGrid\RoomType[x+(y*MapGridSize)] = ROOM2
							Else
								If CurrGrid\Grid[(x-1)+(y*MapGridSize)]>0 And CurrGrid\Grid[x+((y+1)*MapGridSize)]>0 And (x>=0) Then
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 2
								ElseIf CurrGrid\Grid[(x+1)+(y*MapGridSize)]>0 And CurrGrid\Grid[x+((y+1)*MapGridSize)]>0 And(x<MapGridSize-1) Then
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 1
								ElseIf CurrGrid\Grid[(x-1)+(y*MapGridSize)]>0 And CurrGrid\Grid[x+((y-1)*MapGridSize)]>0 And (x>=0) Then
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 3
								Else
									CurrGrid\RoomAngle[x+(y*MapGridSize)] = 0
								EndIf
								CurrGrid\RoomType[x+(y*MapGridSize)] = ROOM2C
							EndIf
						Case 3
							If (Not CurrGrid\Grid[x+((y-1)*MapGridSize)]) Then
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 2
							ElseIf (Not CurrGrid\Grid[(x-1)+(y*MapGridSize)]) And (x>=0) Then
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 1
							ElseIf (Not CurrGrid\Grid[(x+1)+(y*MapGridSize)]) And (x<=MapGridSize-1) Then
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 3
							Else
								CurrGrid\RoomAngle[x+(y*MapGridSize)] = 0
							EndIf
							CurrGrid\RoomType[x+(y*MapGridSize)] = ROOM3
						Case 4
							CurrGrid\RoomAngle[x+(y*MapGridSize)] = Rand(0,3)
							CurrGrid\RoomType[x+(y*MapGridSize)] = ROOM4
					End Select
				EndIf
			Next
		Next
		
		;debuglog "Map Generator Stage 3 complete"
		
		For y = 1 To MapGridSize-2
			For x = 0 To MapGridSize-1
				If CurrGrid\Grid[x+(y*MapGridSize)]>0 Then
					;debuglog CurrGrid\RoomType[x+(y*MapGridSize)]
				EndIf
			Next
		Next
		
		;Assign the "important" rooms into the map first, aka all rooms that have the "commonness" value 0 and the "autospawn" value set to False
		CatchErrors("CreateMap(), Stage 4, Map seed:"+RandomSeed)
		Local rt.RoomTemplates
		Local correctzone%
		For rt.RoomTemplates = Each RoomTemplates
			If rt\Commonness = 0 And rt\AutoSpawn = False Then
				correctzone = False
				If rt\zone[0]=0 Then
					correctzone = True
				Else
					For i = 0 To 1
						If rt\zone[i]=gopt\CurrZone Then
							correctzone = True
							Exit
						EndIf
					Next
				EndIf
				If correctzone Then
					;Be in the loop until it has been positioned successfully
					x = 0
					y = 1
					;debuglog "Trying to spawn "+rt\Name+" with shape "+rt\Shape
					Repeat
						If CurrGrid\Grid[x+(y*MapGridSize)]>0 And CurrGrid\RoomName[x+(y*MapGridSize)]="" Then
							If CurrGrid\RoomType[x+(y*MapGridSize)] = rt\Shape Then
								If Rand(1,5)=1 Then
									CurrGrid\RoomName[x+(y*MapGridSize)] = rt\Name
									;debuglog "Spawned "+rt\Name+" successfully"
									Exit
								EndIf
							EndIf
						EndIf
						x = x + 1
						If x > MapGridSize-1 Then
							x = 0
							y = y + 1
							If y > MapGridSize-2 Then
								y = 0
							EndIf
						EndIf
					Forever
				EndIf
			EndIf
		Next
		
		;debuglog "Map Generator Stage 4 complete"
		
		;Then assign all other rooms (commonness between 1 and 100)
		CatchErrors("CreateMap(), Stage 5, Map seed:"+RandomSeed)
		Local RandomRoom%
		For y = 1 To MapGridSize-2
			For x = 0 To MapGridSize-1
				If CurrGrid\Grid[x+(y*MapGridSize)]>0 And CurrGrid\RoomName[x+(y*MapGridSize)]="" Then
					;First, add all the commonness amounts as one
					temp = 0
					For rt.RoomTemplates = Each RoomTemplates
						If rt\Commonness > 0 Then
							If rt\Shape = CurrGrid\RoomType[x+(y*MapGridSize)] Then
								correctzone = False
								If rt\zone[0]=0 Then
									correctzone = True
								Else
									For i = 0 To 1
										If rt\zone[i]=gopt\CurrZone Then
											correctzone = True
										EndIf
									Next
								EndIf
								If correctzone Then
									temp=temp+rt\Commonness
								EndIf
							EndIf
						EndIf
					Next
					RandomRoom% = Rand(temp)
					temp = 0
					For rt.RoomTemplates = Each RoomTemplates
						If rt\Commonness > 0 Then
							If rt\Shape = CurrGrid\RoomType[x+(y*MapGridSize)] Then
								correctzone = False
								If rt\zone[0]=0 Then
									correctzone = True
								Else
									For i = 0 To 1
										If rt\zone[i]=gopt\CurrZone Then
											correctzone = True
										EndIf
									Next
								EndIf
								If correctzone Then
									temp=temp+rt\Commonness
									If RandomRoom > temp - rt\Commonness And RandomRoom <= temp Then
										CurrGrid\RoomName[x+(y*MapGridSize)] = rt\Name
										;debuglog "Added room "+rt\Name+" successfully"
										Exit
									EndIf
								EndIf
							EndIf
						EndIf
					Next
				EndIf
			Next
		Next
		
		;debuglog "Map Generator Stage 5 complete"
		
		;Create the rooms itself
		Local r.Rooms, spacing# = 8.0
		
		Local zone = gopt\CurrZone
		
		For y = 1 To MapGridSize-2
			For x = 0 To MapGridSize-1
				If CurrGrid\Grid[x+(y*MapGridSize)] > 0 Then
					r = CreateRoom(zone, CurrGrid\RoomType[x+(y*MapGridSize)],x*spacing,0,y*spacing,CurrGrid\RoomName[x+(y*MapGridSize)],CurrGrid\RoomAngle[x+(y*MapGridSize)]*90)
					If r = Null Then
						RuntimeError "Attempt to create room "+CurrGrid\RoomName[x+(y*MapGridSize)]+" was unsuccessful"
					EndIf
				EndIf
			Next
		Next
		
		; ~ Create the start and end rooms for each zone
		
		Select gopt\CurrZone
			Case EZ
				r = CreateRoom(zone, ROOM1, startX*spacing, 0, 0, "gate_a_entrance")
				r\angle = 180
				TurnEntity(r\obj, 0, r\angle, 0)
				r = CreateRoom(zone, ROOM1, endX*spacing, 0, (MapGridSize-1)*spacing, "core_ez")
				r\angle = 0
				CreateRoom(0, ROOM1, 0,100,100,"area_035_ntf_encounter")
			Case BCZ
				r = CreateRoom(zone, ROOM1, startX*spacing, 0, 0, "cont_008")
				r\angle = 180
				TurnEntity(r\obj, 0, r\angle, 0)
				r = CreateRoom(zone, ROOM1, endX*spacing, 0, (MapGridSize-1)*spacing, "checkpoint_bcz")
				r\angle = 0
			Case LCZ
				r = CreateRoom(zone, ROOM1, endX*spacing, 0, (MapGridSize-1)*spacing, "core_lcz")
				r\angle = 0
				TurnEntity(r\obj, 0, r\angle, 0)
				r = CreateRoom(zone, ROOM1, startX*spacing, 0, 0, "room1_start")
				r\angle = 180
				TurnEntity(r\obj, 0, r\angle, 0)
				If opt\IntroEnabled Then
					If gopt\GameMode = GAMEMODE_DEFAULT Then
						r = CreateRoom(0, ROOM1, (MapGridSize+20) * spacing, 0, (MapGridSize+20) * spacing, "room1_intro")
						TurnEntity(r\obj, 0, r\angle, 0)
					EndIf
				EndIf
			Case HCZ
				r = CreateRoom(zone, ROOM1, startX*spacing, 0, 0, "checkpoint_acz")
				r\angle = 180
				TurnEntity(r\obj, 0, r\angle, 0)
				r = CreateRoom(zone, ROOM1, endX*spacing, 0, (MapGridSize-1)*spacing, "core_hcz")
				r\angle = 0
			Case RCZ
				r = CreateRoom(zone, ROOM1, startX*spacing, 0, 0, "checkpoint_rcz")
				r\angle = 180
				TurnEntity(r\obj, 0, r\angle, 0)
				r = CreateRoom(zone, ROOM1, endX*spacing, 0, (MapGridSize-1)*spacing, "area_076_entrance")
				r\angle = 0
		End Select
		
		; ~ Spawn some rooms that are neccesary for the zone
		
		CreateRoom(0, ROOM1, (MapGridSize+1) * spacing, 0, (MapGridSize+1) * spacing, "pocketdimension")
		
		;CreateRoom(0, ROOM1, 0,-300,100,"area_1102_ru")
		
	ElseIf gopt\CurrZone = AREA_076
		CreateRoom(zone, ROOM1, 0, 0, 0, "area_076")
	ElseIf gopt\CurrZone = CLASSD_CELLS
		CreateRoom(zone, ROOM1, 0, 0, 0, "class_d_cells")
	ElseIf gopt\CurrZone = REACTOR_AREA
		CreateRoom(zone, ROOM1, 0, 0, 0, "facility_reactor")
	ElseIf gopt\CurrZone = 0 Then
		CreateRoom(0, ROOM1, 8, 0, 8, "gate_a_intro")
	ElseIf gopt\CurrZone = GATE_A_TOPSIDE Then
		CreateRoom(0, ROOM1, 8, 0, 8, "gate_a_topside")
	ElseIf gopt\CurrZone = GATE_A_ROAD Then
		CreateRoom(0, ROOM1, 8, 0, 8, "gate_a_road")
	ElseIf gopt\CurrZone = GATE_B_TOPSIDE Then
		CreateRoom(0, ROOM1, 8, 0, 8, "gate_b_topside")
	ElseIf gopt\CurrZone = GATE_C_TOPSIDE Then
		CreateRoom(0, ROOM1, 8, 0, 8, "gate_c_topside")
	ElseIf gopt\CurrZone = GATE_D_TOPSIDE Then
		CreateRoom(0, ROOM1, 8, 0, 8, "gate_d_topside")
	ElseIf gopt\CurrZone = AREA_106_ESCAPE
		CreateRoom(zone, ROOM1, 0, 0, 0, "area_106_escape")
	EndIf
	
	;Preventing room overlaps
	For r.Rooms = Each Rooms
		PreventRoomOverlap(r)
	Next
	
	;debuglog "Map Generator Stage 6 complete"
	
	;Add adjacent doors and assign them to the corresponding rooms
	Local d.Doors
	Local shouldSpawnDoor%
	For y = MapGridSize-1 To 0 Step -1
		zone = gopt\CurrZone
		For x = MapGridSize-1 To 0 Step -1
			If CurrGrid\Grid[x+(y*MapGridSize)] > 0 Then
				If zone = HCZ Then temp = DOOR_HCZ ElseIf zone = LCZ Then temp = DOOR_LCZ ElseIf zone = RCZ Then temp = DOOR_HCZ ElseIf zone = BCZ Then temp = DOOR_ONE_SIDED Else temp = DOOR_EZ
                
                For r.Rooms = Each Rooms
					r\angle = WrapAngle(r\angle)
					If Int(r\x/8.0)=x And Int(r\z/8.0)=y Then
						shouldSpawnDoor = False
						Select r\RoomTemplate\Shape
							Case ROOM1
								If r\angle=90 Then
									shouldSpawnDoor = True
								EndIf
							Case ROOM2
								If r\angle=90 Lor r\angle=270 Then
									shouldSpawnDoor = True
								EndIf
							Case ROOM2C
								If r\angle=0 Lor r\angle=90 Then
									shouldSpawnDoor = True
								EndIf
							Case ROOM3
								If r\angle=0 Lor r\angle=180 Lor r\angle=90 Then
									shouldSpawnDoor = True
								EndIf
							Default
								shouldSpawnDoor = True
						End Select
						If shouldSpawnDoor Then
							If (x+1)<(MapGridSize+1) Then
								If CurrGrid\Grid[x+(y*MapGridSize)] > 0 Then
									d.Doors = CreateDoor(r\zone, Float(x) * spacing + spacing / 2.0, 0, Float(y) * spacing, 90, r, Max(Rand(-3, 1), 0), temp)
									r\AdjDoor[0] = d
								EndIf
							EndIf
						EndIf
						
						shouldSpawnDoor = False
						Select r\RoomTemplate\Shape
							Case ROOM1
								If r\angle=180 Then
									shouldSpawnDoor = True
								EndIf
							Case ROOM2
								If r\angle=0 Lor r\angle=180 Then
									shouldSpawnDoor = True
								EndIf
							Case ROOM2C
								If r\angle=180 Lor r\angle=90 Then
									shouldSpawnDoor = True
								EndIf
							Case ROOM3
								If r\angle=180 Lor r\angle=90 Lor r\angle=270 Then
									shouldSpawnDoor = True
								EndIf
							Default
								shouldSpawnDoor = True
						End Select
						If shouldSpawnDoor Then
							If (y+1)<(MapGridSize+1) Then
								If CurrGrid\Grid[x+(y*MapGridSize)] > 0 Then
									d.Doors = CreateDoor(r\zone, Float(x) * spacing, 0, Float(y) * spacing + spacing / 2.0, 0, r, Max(Rand(-3, 1), 0), temp)
									r\AdjDoor[3] = d
								EndIf
							EndIf
						EndIf
						Exit
					EndIf
                Next
			EndIf
		Next
	Next
	CatchErrors("CreateMap(), Determine the adjacent rooms, Map seed:"+RandomSeed)
	;Determine the adjacent rooms
	Local r2.Rooms
	For r.Rooms = Each Rooms
		r\angle = WrapAngle(r\angle)
		SetupTriggerBoxes(r)
		r\Adjacent[0]=Null
		r\Adjacent[1]=Null
		r\Adjacent[2]=Null
		r\Adjacent[3]=Null
		For r2.Rooms = Each Rooms
			If r<>r2 Then
				If r2\z=r\z Then
					If (r2\x)=(r\x+spacing) Then
						r\Adjacent[0]=r2
						If r\AdjDoor[0] = Null Then r\AdjDoor[0] = r2\AdjDoor[2]
					ElseIf (r2\x)=(r\x-spacing)
						r\Adjacent[2]=r2
						If r\AdjDoor[2] = Null Then r\AdjDoor[2] = r2\AdjDoor[0]
					EndIf
				ElseIf r2\x=r\x Then
					If (r2\z)=(r\z-spacing) Then
						r\Adjacent[1]=r2
						If r\AdjDoor[1] = Null Then r\AdjDoor[1] = r2\AdjDoor[3]
					ElseIf (r2\z)=(r\z+spacing)
						r\Adjacent[3]=r2
						If r\AdjDoor[3] = Null Then r\AdjDoor[3] = r2\AdjDoor[1]
					EndIf
				EndIf
			EndIf
			If (r\Adjacent[0]<>Null) And (r\Adjacent[1]<>Null) And (r\Adjacent[2]<>Null) And (r\Adjacent[3]<>Null) Then Exit
		Next
	Next
	
	;debuglog "Map Generator complete"
	
End Function

;-------------------------------------------------------------------------------------------------------

Function load_terrain(hmap,yscale#=0.7,t1%,t2%,mask%)
	
	;debuglog "load_terrain: "+hmap
	
	; load the heightmap
	If hmap = 0 Then RuntimeError "Heightmap image "+hmap+" does not exist."
	
	; store heightmap dimensions
	Local x = ImageWidth(hmap)-1, y = ImageHeight(hmap)-1
	Local lx,ly,index
	
	; load texture and lightmaps
	If t1 = 0 Then RuntimeError "load_terrain error: invalid texture 1"
	If t2 = 0 Then RuntimeError "load_terrain error: invalid texture 2"
	If mask = 0 Then RuntimeError "load_terrain error: invalid texture mask"
	
	; auto scale the textures to the right size
	If t1 Then ScaleTexture t1,x/4,y/4
	If t2 Then ScaleTexture t2,x/4,y/4
	If mask Then ScaleTexture mask,x,y
	
	; start building the terrain
	Local mesh = CreateMesh()
	Local surf = CreateSurface(mesh)
	
	; create some verts for the terrain
	For ly = 0 To y
		For lx = 0 To x
			AddVertex surf,lx,0,ly,1.0/lx,1.0/ly
		Next
	Next
	RenderWorld
			
	; connect the verts with faces
	For ly = 0 To y-1
		For lx = 0 To x-1
			AddTriangle surf,lx+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)
			AddTriangle surf,(lx+1)+((x+1)*ly),lx+((x+1)*ly)+(x+1),(lx+1)+((x+1)*ly)+(x+1)
		Next
	Next
			
	; position the terrain to center 0,0,0
	Local mesh2% = CopyMesh(mesh,mesh)
	Local surf2% = GetSurface(mesh2,1)
	PositionMesh mesh, -x/2.0,0,-y/2.0
	PositionMesh mesh2, -x/2.0,0.01,-y/2.0
	
	; alter vertice height to match the heightmap red channel
	LockBuffer ImageBuffer(hmap)
	LockBuffer TextureBuffer(mask)
	;SetBuffer 
	For lx = 0 To x
		For ly = 0 To y
			;using vertex alpha and two meshes instead of FE_ALPHAWHATEVER
			;it doesn't look perfect but it does the job
			;you might get better results by downscaling the mask to the same size as the heightmap
			Local maskX# = Min(lx*Float(TextureWidth(mask))/Float(ImageWidth(hmap)),TextureWidth(mask)-1)
			Local maskY# = TextureHeight(mask)-Min(ly*Float(TextureHeight(mask))/Float(ImageHeight(hmap)),TextureHeight(mask)-1)
			RGB1=ReadPixelFast(Min(lx,x-1),y-Min(ly,y-1),ImageBuffer(hmap))
			r=(RGB1 And $FF0000)Shr 16 ;separate out the red
			Local alpha#=(((ReadPixelFast(Max(maskX-5,5),Max(maskY-5,5),TextureBuffer(mask)) And $FF000000) Shr 24)/$FF)
			alpha#=alpha+(((ReadPixelFast(Min(maskX+5,TextureWidth(mask)-5),Min(maskY+5,TextureHeight(mask)-5),TextureBuffer(mask)) And $FF000000) Shr 24)/$FF)
			alpha#=alpha+(((ReadPixelFast(Max(maskX-5,5),Min(maskY+5,TextureHeight(mask)-5),TextureBuffer(mask)) And $FF000000) Shr 24)/$FF)
			alpha#=alpha+(((ReadPixelFast(Min(maskX+5,TextureWidth(mask)-5),Max(maskY-5,5),TextureBuffer(mask)) And $FF000000) Shr 24)/$FF)
			alpha#=alpha*0.25
			alpha#=Sqr(alpha)
			
			index = lx + ((x+1)*ly)
			VertexCoords surf, index , VertexX(surf,index), r*yscale,VertexZ(surf,index)
			VertexCoords surf2, index , VertexX(surf2,index), r*yscale,VertexZ(surf2,index)
			VertexColor surf2, index, 255.0,255.0,255.0,alpha
			; set the terrain texture coordinates
			VertexTexCoords surf,index,lx,-ly 
			VertexTexCoords surf2,index,lx,-ly 
		Next
	Next
	UnlockBuffer TextureBuffer(mask)
	UnlockBuffer ImageBuffer(hmap)
	
	UpdateNormals mesh
	UpdateNormals mesh2
	
	EntityTexture mesh,t1,0,0
	;EntityTexture mesh,mask,0,1
	EntityTexture mesh2,t2,0,0;2
	
	EntityFX mesh, 1
	EntityFX mesh2, 1+2+32
	
	Return mesh
End Function

Include "SourceCode\Skybox.bb"

Global UpdateRoomLightsTimer# = 0.0

Function UpdateRoomLights(cam%)
	
	Local r.Rooms, i, random#, alpha#
	
	For r.Rooms = Each Rooms
		If r\dist < HideDistance*0.7 Lor r = PlayerRoom Then
			For i = 0 To r\MaxLights%
				If r\Lights%[i]<>0 Then
					If opt\EnableRoomLights% And (SecondaryLightOn>0.5) And cam%=Camera Then
						EntityOrder r\LightSprites2[i],-1
						If UpdateRoomLightsTimer=0.0 Then
							ShowEntity r\LightSprites[i]
							
							If EntityDistanceSquared(cam%,r\Lights%[i])<PowTwo(8.5) Then
								If r\LightHidden[i] Then
									ShowEntity r\Lights%[i]
									r\LightHidden[i] = False
								EndIf
							Else
								If (Not r\LightHidden[i]) Then
									HideEntity r\Lights%[i]
									r\LightHidden[i] = True
								EndIf
							EndIf
							
							If (EntityDistanceSquared(cam%,r\LightSprites2[i])<PowTwo(8.5) Lor r\RoomTemplate\UseLightCones) Then
								If EntityVisible(cam%,r\LightSpritesPivot[i]) Lor r\RoomTemplate\UseLightCones Then
									If r\LightSpriteHidden%[i] Then
										ShowEntity r\LightSprites2%[i]
										r\LightSpriteHidden%[i] = False
									EndIf
									If PlayerRoom\RoomTemplate\Name$ = "cont_173" Then
										random# = Rnd(0.38,0.42)
									Else
										If r\LightFlicker%[i]<5 Then
											random# = Rnd(0.38,0.42)
										ElseIf r\LightFlicker%[i]>4 And r\LightFlicker%[i]<10 Then
											random# = Rnd(0.35,0.45)
										Else
											random# = Rnd(0.3,0.5)
										EndIf
									EndIf
									ScaleSprite r\LightSprites2[i],random#,random#
									
									alpha# = Float(Inverse(Max(Min((EntityDistance(cam%,r\LightSpritesPivot[i])+0.5)/7.5,1.0),0.0)))
									
									If alpha# > 0.0 Then
										EntityAlpha r\LightSprites2[i],Max(3*(Brightness/255)*(r\LightIntensity[i]/2),1)*alpha#
									Else
										;Instead of rendering the sprite invisible, just hiding it if the player is far away from it
										If (Not r\LightSpriteHidden%[i]) Then
											HideEntity r\LightSprites2[i]
											r\LightSpriteHidden%[i]=True
										EndIf
									EndIf
									
									If r\RoomTemplate\UseLightCones Then
										If EntityDistanceSquared(cam%,r\LightSprites2[i])>=PowTwo(8.5) Lor (Not EntityVisible(cam%,r\LightSpritesPivot[i])) Then
											HideEntity r\LightSprites2%[i]
											r\LightSpriteHidden%[i] = True
										EndIf
									EndIf
								Else
									If (Not r\LightSpriteHidden%[i]) Then
										HideEntity r\LightSprites2%[i]
										r\LightSpriteHidden%[i] = True
									EndIf
								EndIf
							Else
								If (Not r\LightSpriteHidden%[i]) Then
									HideEntity r\LightSprites2%[i]
									r\LightSpriteHidden%[i] = True
									If r\LightCone[i]<>0 Then
										HideEntity r\LightCone[i]
									EndIf
									If r\LightConeSpark[i]<>0 Then
										HideEntity r\LightConeSpark[i]
									EndIf
								EndIf
								
								If r\LightCone[i]<>0 Then
									ShowEntity r\LightCone[i]
								EndIf
								
								If r\LightConeSpark[i]<>0 Then
									If r\LightConeSparkTimer[i]>0 And r\LightConeSparkTimer[i]<10 Then
										ShowEntity r\LightConeSpark[i]
										r\LightConeSparkTimer[i]=r\LightConeSparkTimer[i]+FPSfactor
									Else
										HideEntity r\LightConeSpark[i]
										r\LightConeSparkTimer[i]=0
									EndIf
								EndIf
								
								If r\LightCone[i]<>0 Then
									ScaleEntity r\LightCone[i],0.005+Max(((-0.4+random#)*0.025),0),0.005+Max(((-0.4+random#)*0.025),0),0.005+Max(((-0.4+random#)*0.025),0)
									If r\LightFlicker%[i]>4 Then
										If Rand(400)=1 Then
											;SetEmitter(r\LightSpritesPivot[i],ParticleEffect[0])
											PlaySound2(IntroSFX[Rand(1,3)],cam,r\LightSpritesPivot[i])
											ShowEntity r\LightConeSpark[i]
											r\LightConeSparkTimer[i] = FPSfactor
										EndIf
									EndIf
								EndIf
							EndIf
						Else
							If (EntityDistanceSquared(cam%,r\LightSprites2[i])<PowTwo(8.5) Lor r\RoomTemplate\UseLightCones) Then
								If PlayerRoom\RoomTemplate\Name$ = "cont_173" Then
									random# = Rnd(0.38,0.42)
								Else
									If r\LightFlicker%[i]<5 Then
										random# = Rnd(0.38,0.42)
									ElseIf r\LightFlicker%[i]>4 And r\LightFlicker%[i]<10 Then
										random# = Rnd(0.35,0.45)
									Else
										random# = Rnd(0.3,0.5)
									EndIf
								EndIf
								
								If (Not r\LightSpriteHidden[i]) Then
									ScaleSprite r\LightSprites2[i],random#,random#
								EndIf
							EndIf
							
							If r\LightCone[i]<>0 Then
								ScaleEntity r\LightCone[i],0.005+Max(((-0.4+random#)*0.025),0),0.005+Max(((-0.4+random#)*0.025),0),0.005+Max(((-0.4+random#)*0.025),0)
							EndIf
							
							If r\LightConeSpark[i]<>0 Then
								If r\LightConeSparkTimer[i]>0 And r\LightConeSparkTimer[i]<10 Then
									ShowEntity r\LightConeSpark[i]
									r\LightConeSparkTimer[i]=r\LightConeSparkTimer[i]+FPSfactor
								Else
									HideEntity r\LightConeSpark[i]
									r\LightConeSparkTimer[i]=0
								EndIf
							EndIf
						EndIf
					ElseIf cam%=Camera Then
						If SecondaryLightOn<=0.5 Then
							HideEntity r\LightSprites[i]
						Else
							ShowEntity r\LightSprites[i]
						EndIf
						
						If (Not r\LightHidden[i]) Then
							HideEntity r\Lights%[i]
							r\LightHidden[i] = True
						EndIf
						If (Not r\LightSpriteHidden[i]) Then
							HideEntity r\LightSprites2[i]
							r\LightSpriteHidden[i]=True
						EndIf
						If r\LightCone[i]<>0 Then
							HideEntity r\LightCone[i]
						EndIf
						If r\LightConeSpark[i]<>0 Then
							HideEntity r\LightConeSpark[i]
						EndIf
					Else
					;This will make the lightsprites not glitch through the wall when they are rendered by the cameras
						EntityOrder r\LightSprites2[i],0
					EndIf
				EndIf
			Next
		EndIf
	Next
	
	UpdateRoomLightsTimer = UpdateRoomLightsTimer + FPSfactor
	If UpdateRoomLightsTimer >= 8 Then
		UpdateRoomLightsTimer = 0.0
	EndIf
	
End Function

Function AmbientLightRooms(value%=0)
	Local mesh%,surf%,brush%,tex0%
	
	If value=AmbientLightRoomVal Then Return
	AmbientLightRoomVal = value
	
	Local oldbuffer% = BackBuffer()
	
	SetBuffer TextureBuffer(AmbientLightRoomTex)
	
	ClsColor value,value,value
	Cls
	ClsColor 0,0,0
	
	SetBuffer oldbuffer
End Function

Type ElevatorObj
	Field obj%
	Field InFacility%
	Field door.Doors
End Type

Function AssignElevatorObj.ElevatorObj(obj%,door.Doors,in_facility%)
	Local eo.ElevatorObj = New ElevatorObj
	
	eo\obj% = obj%
	eo\door = door
	eo\InFacility% = in_facility%
	
	Return eo
End Function

Function DeleteElevatorObjects()
	
	Delete Each ElevatorObj
	
End Function

Function ValidRoom2slCamRoom(r.Rooms)
	If (r = Null) Then
		Return False
	EndIf
	
	Local RN$ = r\RoomTemplate\Name$
	
	If RN$ = "room2closets" Then Return True
	If RN$ = "room1archive" Then Return True
	If RN$ = "room3z3" Then Return True
	If RN$ = "room1lifts" Then Return True
	If RN$ = "checkpoint1" Then Return True
	If RN$ = "room2nuke" Then Return True
	If RN$ = "008" Then Return True
	If RN$ = "room1162" Then Return True
	If RN$ = "room966" Then Return True
	If RN$ = "room2ccont" Then Return True
	
	Return False
	
End Function

Function FindAndDeleteFakeMonitor(r.Rooms,x#,y#,z#,Amount%)
	Local i%
	
	For i = 0 To Amount%
		If r\Objects[i]<>0
			If EntityX(r\Objects[i],True) = x#
				If EntityY(r\Objects[i],True) = y#
					If EntityZ(r\Objects[i],True) = z#
						r\Objects[i] = FreeEntity_Strict(r\Objects[i])
						;debuglog "Deleted Fake Monitor: "+i
						Exit
					EndIf
				EndIf
			EndIf
		EndIf
	Next
	
End Function

Function AddLightCones(room.Rooms)
	Local i
	
	For i = 0 To MaxRoomLights-1
		If room\Lights[i]<>0
			room\LightCone[i] = CopyEntity(LightConeModel)
			ScaleEntity room\LightCone[i],0.01,0.01,0.01
			EntityColor room\LightCone[i],room\LightR[i],room\LightG[i],room\LightB[i]
			EntityAlpha room\LightCone[i],0.15
			EntityBlend room\LightCone[i],3
			PositionEntity room\LightCone[i],EntityX(room\LightSpritesPivot[i],True),EntityY(room\LightSpritesPivot[i],True),EntityZ(room\LightSpritesPivot[i],True),True
			EntityParent room\LightCone[i],room\LightSpritesPivot[i]
			
			If room\LightFlicker%[i] > 4
				room\LightConeSpark[i] = CreateSprite()
				ScaleSprite room\LightConeSpark[i],1.0,1.0
				;EntityTexture room\LightConeSpark[i],ParticleTextures[8]
				SpriteViewMode room\LightConeSpark[i],2
				EntityFX room\LightConeSpark[i],1
				RotateEntity room\LightConeSpark[i],-90,0,0
				EntityBlend room\LightConeSpark[i],3
				EntityAlpha room\LightConeSpark[i],1.0
				PositionEntity room\LightConeSpark[i],EntityX(room\LightSpritesPivot[i],True),EntityY(room\LightSpritesPivot[i],True)+0.05,EntityZ(room\LightSpritesPivot[i],True),True
				EntityParent room\LightConeSpark[i],room\LightSpritesPivot[i]
			EndIf
		EndIf
	Next
	
End Function

Function CalculateRoomTemplateExtents(r.RoomTemplates)
	If r\DisableOverlapCheck Then Return
	
	GetMeshExtents(GetChild(r\obj,2))
	r\MinX = Mesh_MinX
	r\MinY = Mesh_MinY
	r\MinZ = Mesh_MinZ
	r\MaxX = Mesh_MaxX
	r\MaxY = Mesh_MaxY
	r\MaxZ = Mesh_MaxZ
	
	;debuglog("roomtemplateextents: "+r\MinX+", "+r\MinY	+", "+r\MinZ	+", "+r\MaxX	+", "+r\MaxY+", "+r\MaxZ)
End Function

Function CalculateRoomExtents(r.Rooms)
	If r\RoomTemplate\DisableOverlapCheck Then Return
	
	;shrink the extents slightly - we don't care if the overlap is smaller than the thickness of the walls
	Local shrinkAmount# = 0.05
	
	;convert from the rooms local space to world space
	TFormVector(r\RoomTemplate\MinX, r\RoomTemplate\MinY, r\RoomTemplate\MinZ, r\obj, 0)
	r\MinX = TFormedX() + r\x
	r\MinY = TFormedY()
	r\MinZ = TFormedZ() + r\z
	
	;convert from the rooms local space to world space
	TFormVector(r\RoomTemplate\MaxX, r\RoomTemplate\MaxY, r\RoomTemplate\MaxZ, r\obj, 0)
	r\MaxX = TFormedX() + r\x
	r\MaxY = TFormedY()
	r\MaxZ = TFormedZ() + r\z
	
	If (r\MinX > r\MaxX) Then
		Local tempX# = r\MaxX
		r\MaxX = r\MinX
		r\MinX = tempX
	EndIf
	If (r\MinZ > r\MaxZ) Then
		Local tempZ# = r\MaxZ
		r\MaxZ = r\MinZ
		r\MinZ = tempZ
	EndIf
	
	r\MinX = r\MinX + shrinkAmount : r\MaxX = r\MaxX - shrinkAmount
	r\MinY = r\MinY + shrinkAmount : r\MaxY = r\MaxY - shrinkAmount
	r\MinZ = r\MinZ + shrinkAmount : r\MaxZ = r\MaxZ - shrinkAmount
	
	;;debuglog("roomextents: "+r\MinX+", "+r\MinY	+", "+r\MinZ	+", "+r\MaxX	+", "+r\MaxY+", "+r\MaxZ)
End Function

Function CheckRoomOverlap(r1.Rooms, r2.Rooms)
	If (r1\MaxX	<= r2\MinX Lor r1\MaxY <= r2\MinY Lor r1\MaxZ <= r2\MinZ) Then Return False
	If (r1\MinX	>= r2\MaxX Lor r1\MinY >= r2\MaxY Lor r1\MinZ >= r2\MaxZ) Then Return False
	
	Return True
End Function

Function PreventRoomOverlap(r.Rooms)
	If r\RoomTemplate\DisableOverlapCheck Then Return
	
	Local r2.Rooms,r3.Rooms
	
	Local isIntersecting% = False
	
	;Just skip it when it would try to check for the checkpoints
	;If r\RoomTemplate\Name = "checkpoint_ez" Lor r\RoomTemplate\Name = "checkpoint_lcz" Lor r\RoomTemplate\Name = "checkpoint_ez" Then Return True
	If r\RoomTemplate\AutoSpawn Then Return True
	
	;First, check if the room is actually intersecting at all
	For r2 = Each Rooms
		If r2 <> r And (Not r2\RoomTemplate\DisableOverlapCheck) Then
			If CheckRoomOverlap(r, r2) Then
				isIntersecting = True
				Exit
			EndIf
		EndIf
	Next
	
	;If not, then simply return it as True
	If (Not isIntersecting)
		Return True
	EndIf
	
	;Room is interseting: First, check if the given room is a ROOM2, so we could potentially just turn it by 180 degrees
	isIntersecting = False
	Local x% = r\x/8.0
	Local y% = r\z/8.0
	If r\RoomTemplate\Shape = ROOM2 Then
		;Room is a ROOM2, let's check if turning it 180 degrees fixes the overlapping issue
		r\angle = r\angle + 180
		RotateEntity r\obj,0,r\angle,0
		CalculateRoomExtents(r)
		
		For r2 = Each Rooms
			If r2 <> r And (Not r2\RoomTemplate\DisableOverlapCheck) Then
				If CheckRoomOverlap(r, r2) Then
					;didn't work -> rotate the room back and move to the next step
					isIntersecting = True
					r\angle = r\angle - 180
					RotateEntity r\obj,0,r\angle,0
					CalculateRoomExtents(r)
					Exit
				EndIf
			EndIf
		Next
	Else
		isIntersecting = True
	EndIf
	
	;room is ROOM2 and was able to be turned by 180 degrees
	If (Not isIntersecting)
		;debuglog "ROOM2 turning succesful! "+r\RoomTemplate\Name
		Return True
	EndIf
	
	;Room is either not a ROOM2 or the ROOM2 is still intersecting, now trying to swap the room with another of the same type
	isIntersecting = True
	Local temp2,x2%,y2%,rot%,rot2%
	For r2 = Each Rooms
		If r2 <> r And (Not r2\RoomTemplate\DisableOverlapCheck)  Then
			;If r\RoomTemplate\Shape = r2\RoomTemplate\Shape And r\zone = r2\zone And (r2\RoomTemplate\Name <> "checkpoint1_new" And r2\RoomTemplate\Name <> "checkpoint2_new" And r2\RoomTemplate\Name <> "start") Then
			If r\RoomTemplate\Shape = r2\RoomTemplate\Shape And r\zone = r2\zone And r2\RoomTemplate\AutoSpawn=False Then
				x = r\x/8.0
				y = r\z/8.0
				rot = r\angle
				
				x2 = r2\x/8.0
				y2 = r2\z/8.0
				rot2 = r2\angle
				
				isIntersecting = False
				
				r\x = x2*8.0
				r\z = y2*8.0
				r\angle = rot2
				PositionEntity r\obj,r\x,r\y,r\z
				RotateEntity r\obj,0,r\angle,0
				CalculateRoomExtents(r)
				
				r2\x = x*8.0
				r2\z = y*8.0
				r2\angle = rot
				PositionEntity r2\obj,r2\x,r2\y,r2\z
				RotateEntity r2\obj,0,r2\angle,0
				CalculateRoomExtents(r2)
				
				;make sure neither room overlaps with anything after the swap
				For r3 = Each Rooms
					If (Not r3\RoomTemplate\DisableOverlapCheck) Then
						If r3 <> r Then
							If CheckRoomOverlap(r, r3) Then
								isIntersecting = True
								Exit
							EndIf
						EndIf
						If r3 <> r2 Then
							If CheckRoomOverlap(r2, r3) Then
								isIntersecting = True
								Exit
							EndIf
						EndIf	
					EndIf
				Next
				
				;Either the original room or the "reposition" room is intersecting, reset the position of each room to their original one
				If isIntersecting Then
					r\x = x*8.0
					r\z = y*8.0
					r\angle = rot
					PositionEntity r\obj,r\x,r\y,r\z
					RotateEntity r\obj,0,r\angle,0
					CalculateRoomExtents(r)
					
					r2\x = x2*8.0
					r2\z = y2*8.0
					r2\angle = rot2
					PositionEntity r2\obj,r2\x,r2\y,r2\z
					RotateEntity r2\obj,0,r2\angle,0
					CalculateRoomExtents(r2)
					
					isIntersecting = False
				EndIf
			EndIf
			
		EndIf
	Next
	
	;room was able to the placed in a different spot
	If (Not isIntersecting)
		;debuglog "Room re-placing successful! "+r\RoomTemplate\Name
		Return True
	EndIf
	
	;debuglog "Couldn't fix overlap issue for room "+r\RoomTemplate\Name
	Return False
End Function













;~IDEal Editor Parameters:
;~C#Blitz3D